;;
;; File: userdoc.txt
;; Desc: User documentation
;; Vers: 8.29
;; Auth: dmp
;;

alps user guide
---------------

Introduction
------------

alps is a simple lisp interpreter that incorporates most of the array
processing primitives from APL\360. The lisp dialect is primarily that
of the original LISP1.5. Alps stands for "An Array and List Processing
System" or "A Lisp Personal System". It is designed for use as an
interactive personal computing environment that encourages
experimentation with code and data. It derives its simplicity from
using only original lisp syntax without syntactic sugar. Nevertheles
it is extremely powerful thanks to the mostly happy marriage of the
functional nature of lisp with the array processing and manipulation
primitives of APL. Programmes can be coded very concisely affording
economy of typing and navigation. Alps is a pure interpreter that
directly interprets its internal list representaion without any
intermediate code. This facilitates debugging and creating code that
generates code for execution. Performance should be adequate for most
personal needs on modern equipment.

Getting started
----------------

Installing: 
Installing alps creates a directory "alps" in your current directory
and copies the files to it.

For Un*x systems:
1) Obtain a binary distribution alpsRX-XX.tgz 
   where X-XX is the revision number. 
2) Change to the directory in which you wish the alps directory to be
created
3) Extract the files: tar xzvf alpsX-XX.tgz
4) Put the alps/bin directory in your execution path or link the
alps executable into a directory in your current execution path.
5) Copy the file lisp/doalps to the alps directory as .alps and modify
it to your needs. .alps is read by alps at startup

Invoking alps:

From a shell prompt simply type: alps

Example:
bash$ alps
alps LINUX 32bit Interpreter V6.99
loading .alps
loading prims.al
loading dll.al
loading qt.al
alps: 

Using alps:

alps is an interpreter that evaluates lisp expressions. By default it
enters a prompt-read-eval-print loop. At the "alps:" prompt enter any
valid expression to evaluate it and print the result.  A semicolon and
all characters following it on a line are ignored. The semicolon is
used to introduce comments so we use it here to annotate the examples.
A lisp expression is either a constant, symbol or an expression in
brackets with 0 or more elements. Any element in a bracket expression
can again be a constant, symbol or another expression in brackets.
The first element in an evaluated bracket expression must always refer
to a function while the remaining elements are its arguments.

Example dialog:
alps: (+ 2 2)
4
alps: (+ 1 2 3 4)              ; + takes any number of arguments
10
alps: (+ 1 2 3 (+ 2 2))        ; using an expression as an argument
10
alps: (a Foo [1 2 3 4])        ; assign to the symbol Foo the vector [1 2 3 4]
alps: Foo                      ; examine the value of Foo
[1 2 3 4]                      ; value of Foo printed
alps: (* Foo 10)               ; multiply the elements of Foo by 10
[10 20 30 40]
alps: (a Bar (list 1 2 'Foo Foo  "polly")) ; assign to Bar a list 
alps: Bar                                  ; examine the value of Bar
(1 2 Foo [1 2 3 4]  "polly")
; prepend the symbol Hello to the rest of the list after the first element  
alps: (cons 'Hello (cdr Bar))  
(Hello 2 Foo [1 2 3 4]  "polly")
alps:

To exit the interpreter enter the expresion (quit) or send an end-of-file
by entering the appropriate control character (control-d for most unixen).

Example:
alps: (quit)

/alps: Session ended per user request.
bash$ 

Learning alps
-------------

If you are unfamiliar with LISP an excellent introduction is:
LISP: A Gentle Introduction to Symbolic Computation by David S. Touretzky
Longman Higher Education (1 May 1984) ISBN: 978-0060466572
Be sure to get the first edition, later editions deal with Common Lisp
which is not suitable.

The alps LISP dialect is very simple so reading through the reference
section and playing with a few of the examples will get you going also.

For the APL aspects a good place to start is to read the annotated files
lisp/idioms.al and lisp/tot.al and trying out examples.


Introduction to the Line editor
-------------------------------

When entering an expression at the alps prompt the facilities of the
built-in line editor are available. For a full description see the
reference section Line editor and history commands.

Text is entered by simply typing the characters of the expression.
Insert text at a particular point by moving the cursor there and
typing the text.

Moving the cursor around the expression:
<ctrl-a> Moves the cursor to the beginning of the line
<ctrl-e> Moves to the end of the line
<ctrl-b> or <Back-arrow> Moves back one character
<ctrl-f> or <Forward-arrow> Moves forward one character

Deleting text:
<ctrl-d> Deletes the character on the cursor
<ctrl-h> or <Backspace> Deletes the character before the cursor
<ctrl-k> Kills the text from the cursor to the end of the line

History:
<ctrl-p> Recalls the previous line entered
<ctrl-n> Recalls the next line entered

Reference Section
-----------------

The remainder of this guide is organised as follows:

How to use the guide

Basic concepts

Built in function reference guide

Conventions used in this user guide
-----------------------------------

An equal sign followed by a greater sign => indicates denotation, or a
message produced. If it is preceded by a semicolon ;=> it indicates
the result produced by the expression on its left which can used as a
value in further computations. This is used to facilitate the use of
cut and paste in the examples. One can cut a line from this guide
and paste it into the interpreter without having the result or
subsequent characters evaluated. The second semicolon serves to
delimit the comment from the result for readability.

Examples:

   asd => error sys_eval Unbound symbol: asd

   "abc\"def" => abc"def

   "abc\"def" ;=> "abc\"def" ;a string with an embedded double quote

   (+ 1 2 3 4) ;=> 10      ;the sum of the first four positive integers

When referring to built-in functions in explanatory text they are
enclosed in parentheses. For example:

"The (cons) function creates a cons cell, placing its first argument
in the head and the second argument in the tail."

Terms with a special meaning are enclosed in left and right angle
braces. They are used for system types such as <subr> which have no
external representation. They are also used around the formal
parameters of expression such as: (de name parms body) so that <name>
and <body> be referred to in the subsequent explanatory text without
confusion. When a formal parameter is postfixed with a plus sign or
asterisk it means respectively that one-or-more and zero-or-more
consecutive repetitions of the parameter may occur in the
expression. Note that angle braces are not used in the presentation of
syntax for literals. Square braces are used to denote optional
parameters. Double colon equals denotes a syntax definition. Types for
arguments are indicated by following the symbol in angle braces by a
colon and the type. The list of types is given in the introduction to
the reference section.

In the syntax description of (setq) given here, note the use of the
asterisk indicating that (setq) can take zero or more
Symbol-Value-Pairs as arguments.

Syntax:    (setq Symbol-Value-Pair*)
Arguments: Symbol-Value-Pair ::= Symbol Value
	   Symbol:symb
The square braces around the <axis> argument in the syntax description
of (explod) indicate that it is optional.

Syntax:    (explod [axis] arg)
Arguments: arg:any array
           axis:numeric singleton


Basic concepts
--------------

Data Types
----------

The system supports 3 basic data types:

1) Numbers: which are implemented with IEEE 754 double precision floating point.

2) Characters: Ascii 8 bit characters

3) References: refer to data structures and are implemented as pointers

Data Structures
---------------

The functions of the system operate on 3 data structures:

Atoms, Cons Cells and Lists. These are described in more detail below.

Atoms: These are the basic data units of the lisp environment. 
       Atoms come in three flavours:

       Constants: These are instances of single numbers or arrays of
                  numbers, characters or references. They can be
                  classified into arrays, matrices, vectors or
                  scalars. An array is a structure of 1 or more
                  dimensions containing values of the same data
                  type. The number of dimensions of an array is called
                  its rank. A one dimensinal array is called a vector:
                  [1 2 3 4 5], or "abcde". A two dimensional array is
                  called a matrix. The shape of an array is a vector
                  with as many elements as the array has
                  dimensions. The value of each element of the shape
                  vector represents the size of the dimension
                  corresponding to its position in the vector. For
                  example if we have a 3 x 4 x 5 array then its rank
                  is 3 and its shape vector is [3 4 5].  A scalar is
                  simply a single number. For example 1.3 is a
                  scalar. The shape of a scalar is the null vector and
                  it has a rank of zero. Character and reference atoms
                  never have a rank of zero.
		  
       Symbols: A symbol is an atom with which values and properties
                can be associated. A symbol is denoted by its name
                which is a character vector. For a detailed
                description of valid symbol names see the section on
                "Symbols" below.  Symbols have the same role as
                variable names in other programming languages. Note
                however that symbols are untyped. Objects of any type
                can be assigned or "bound" to a symbol.

       System objects: such as files, buffers and tasks are also
                       atoms. In general users do not need to deal
                       with these.


Cons Cells: A cons cell is the basic element of a list. It has two
            slots: a head and a tail which are references.

Lists: A list is a chain of cons cells where the tail of each cons
       cell in the list refers to or points to the next cons cell in
       the list except for the tail of the last cons cell in the list
       which contains a reference to the special symbol nil. Although
       not a primitive data structure it is treated as such by the
       list processing primitives.



Symbols
-------

The name of a general symbol can start with any printable ASCII
character except the special symbol characters and the ' <quote>
character. They can additionally contain zero or more printable ASCII
characters except the special symbol characters. The special symbols
are comprised of the 12 single characters:

			"`,;:\()[]{}

Symbols are delimited by these special symbols and space.

For example the following are valid symbols:

        X y Temperature flag? A001 &B object-list B.3 1+ *Fred* Theta'

The following  are not valid symbols:
                
	1  1.0 "asd" ,a :fred  'a

Note: The setting of the input-base #IB (radix) affects the
recognition of symbols. For example, if #IB is greater than 10 then 0A
is treated as the numeric litteral 10 instead of the symbol 0A. So in
general if #IB will be set to values greater than 10 one should avoid
using symbols that start with 0 folowed by an upper case alphabetic
character followed by digits or upper case alphabetic characters.

Logical constants
-----------------

There are two sets of logical constants:
the lisp logical constants t and nil
and the APL logical constants 1 and 0.
The former are used in list processing and program programme execution flow and
the latter as logical values in computational expressions.

Lisp logical constants
----------------------
In addition to the special symbol characters which are used as
syntactical delimeters for the Alps Lisp dialect there are two special
built-in immutable symbols that constitute the lisp logical constants:

nil 
Special built-in immutable symbol represents the empty list. 
nil is also an atom and signals the end of a list when
it occurs in the tail reference of a cons cell.
Finally nil is the atom that represents the lisp logical value false,
the negation of true. It is the only value representing
the negation of true.

t 
Special built-in immutable synbol representing the logical value
true. It is an atom. Any non-nil value also represents the logical
value true in the application of lisp predicates.


APL logical constants
---------------------

The APL logical constants for false and true are the numeric
values 0 and 1 respectively. Since they are numeric they can
be used directly in arithmetic operations.
For example to set each element greater than 6 to 0 in a vector
V => [1 2 3 4 5 6 7 8 9 10]
(> 6 V )     ;=> [1 1 1 1 1 0 0 0 0 0]
(* V(> 6 V)) ;=> [1 2 3 4 5 0 0 0 0 0]

The empty vectors
-----------------

An empty vector has rank 1 and shape [0].
Numeric   empty vector  []
Character empty vector  ""
reference empty vector $[]


Fill elements
-------------

Certain functions need to insert default values into the arrays they
generate. For numeric arrays the fill element is 0, for character
arrays it is " " the space character and for reference arrays it is
nil.

Literals
--------
Literals are used to represent the values of atomic constants when
entering expressions into the interpreter.

Character Literals
------------------

Character literals are comprised of a sequence of characters enclosed
in double quotes.

"abcde" ;=> abcde

The escape character \ can be used to insert double quotes " and
newlines into a string literal as well as to quote itself:

"ab\"cde"   => ab"cde

"\"abcde\"" => "abcde"

"ab\\cde"   => ab\cde

"ab'cde"    => ab'cde

The escape character is also used to enter control characters such as 
"\A" for <control-A> which has an ASCII value of 1.

Two special escape characters are \n and \q. 
\n represents the <newline> character ASCII value 10
\q represents the character with ASCII value 28

"abcde\n" => abcde<newline>

"ab\ncde" => ab<newline>cde

"ab
cde"      => ab<newline>cde

An escape character followed immediately by a <newline> allows entry
of a multiline character literal while suppressing the actual
<newline> characters in the literal.

"ab\
cde"      ;=> "abcde" 

A full list of escape character sequences appears in the appendix.

The null string or zero length string is represented as "" The shape
function (p X) returns a vector with the dimensions of its argument X
(see shape). For strings, which are actually character vectors, the
shape function returns the length of the string. To find the length of
a string X use (p X).

(p "")       ;=> [0]
(p "a")      ;=> [1]
(p "abc")    ;=> [3]
(p 'a)       ;=> [1] 

The monadic shape function (p) always returns a vector. To obtain the
scalar length one can use the dyadic form of (p) to reshape the shape
of the argument to a scalar: (p [] (p <argument>))

(p [] (p "Hello")) ;=> 5

or use the (tally) function which returns the length of the first
dimension of its argument as a scalar.

(tally "Ho") ;=> 2


Numeric literals
----------------

Numeric literals start with a digit or point or with a digit or point
prefixed with a + or - sign. A leading point must be followed by one
or more digits otherwise it is scanned as a Special-symbol. If the
current input-base #IB is greater than 10 and the first digit is not a
decimal digit and there is no leading + or - sign or period then a
leading 0 is required for real values. A special prefix '0x'
intruduces a hexadecimal litteral comprised of decimal digits and the
letters A-F.

A complex numeric literal is comprised of two numeric literals
separated by the character "j". A numeric literal must be delimited by
a space or a special symbol otherwise it is treated as a symbol.

Examples of numeric literals:

1
-1
+1
1.2
3.14
.222
-.333
1e3
12.3e-3
1e+02
1j1
0j1
12.34j5e-5
0j ;=> 0
1j ;=> 1
0xA1 ;=> 161
0xA1j0xA2 ;=> 161j162
(a #IB 16)
#IB ;=> 16
0A ;=> 10
0A.8  ;=> 10.5
-A.8  ;=> -10.5
+A.8  ;=> 10.5
.A    ;=> .625
+A.8jC ;=> 10.5j12

Examples of non valid numeric literals (scanned as symbols)

1x                ; x not a special symbol
1.1.              ; . not a special symbol
1.2e              ; no digits after exponent 
1+                ; no e before +
1'                ; ' not a special symbol
A.8jC             ; for #IB > 10 no leading 0 on real part

Lisp literals
-------------

Lisp literals are syntactic components that correspond to lisp
structures. The lisp reader of the interpreter reads the text of an
input expression and produces the corresponding lisp data
structures. The grammar for input expressions is described
semi-formally in the section #Symbolic Expressions. An input
expression is a symbolic expression abbreviated as S-Expression.

An S-Expression is either an atom, or a pair of S-Expressions in
parentheses separated by a dot.

An atom is any literal or symbol. Here we will use the symbols A, B
and C for simplicity.

A, B and C are atoms as well as S-Expressions.

(A . B) is an S-Expression that corresponds to a Cons Cell with a
reference to A in the head and a reference to B in the tail.

    +---------+
    | .  |  . |
    +-|-----|-+
      |     |
      v     v
      
      A     B

The notation (A . B) is called dotted pair notation.

((A . B) . C) Produces a lisp structure comprised of two cons cells, the
first having (A.B) and C as its components and the second having A and
B as its components,

    +---------+
    | .  |  . |
    +-|-----|-+
      |     |
      |     +----> C
      v
    +---------+
    | .  |  . |
    +-|-----|-+
      |     |
      v     v
      
      A     B   

To construct the list of A, B and C using dotted pair notation:
(A . (B . (C . nil)))
 

    +---------+     +---------+     +---------+     
    | .  |  --|---->| .  |  --|---->| .  |  --|----> nil
    +-|-------+	    +-|-------+     +-|-------+     
      |       	      |               |             
      v     	      v               v             
      		                                    
      A               B               C             

                                                                          
To avoid the complexity of dotted pair notation and faclitate the
entry of lists the lisp reader automatically creates a list from a
list of S-Expressions enclosed in parentheses

(A B C) <=> (A . (B . (C . nil)))

Normally there is never any need for dotted pair notation when
entering expressions.

By default each expression entered into the system is read by the lisp
reader and the resulting structure is passed to the interpreter to be
evaluated and the result printed.

If the expression (A B C) is evaluated it expects A to be a function
with B and C its arguments. For example to print the length of a list
the function (len) can be used.

(len (A B C)) would return the length of the result of applying A to
the values of B and C. If A is not a function an error would result.

To pass the unevaluated structure the structure is given to a special
function which returns its argument as is without evaluating it.

The function (quote) and its shorthand symbol ' are used for
this purpose. All atoms with exception of the general symbols evaluate
to themselves and therefore need not be quoted. The function (quote)
returns its argument without evaluating it.

Here are two ways to quote the symbol A 
(quote A) ;=> A
'A        ;=> A

(quote A) or equivalently 'A produces the following lisp structure

    +---------+     +---------+ 
    | .  |  --|---->| .  |  --|----> nil
    +-|-------+	    +-|-------+ 
      |       	      |         
      v     	      v         
      		                
    quote             A         
                                

To quote an expression
(quote (A . B))   ;=> (A . B)
'(A . B)          ;=> (A . B)
(quote (+ 1 2)) ;=> (+ 1 2)
'(+ 1 2)        ;=> (+ 1 2)
(+ 1 2)         ;=> 3

To quote a list of objects:

(quote (A B C)) ;=> (A B C)
'(A B C)        ;=> (A B C)
(len '(A B C))  ;=> 3

(quote (a b 124 c [123 456 789])) ;=> (a b 124 c [123 456 789])
'(a b 124 c [123 456 789])        ;=> (a b 124 c [123 456 789])

Assume the symbols A,B and C have the following values:
"abc" 123  and '(a b c) respectively. The function (list) creates a list of
the result of evaluating each of its arguments:

(list A B C 10) ;=> ("abc" 123 (a b c) 10)

If instead of the value of A it is required to have the symbol A in the
resulting list the quote construct can be used:

(list 'A B C 10) ;=> (A 123 (a b c) 10)

'A is just a shorthand form of (quote A). The lisp reader transforms
the input '<expression> to (quote <expression>) i.e. a list comprised
of two elements: the symbol quote and <expression>

(quote (quote A)) ;=> 'A
''A               ;=> 'A

For conciseness the print function automatically transforms
(quote <exp>) to '<exp> on output where <exp> is a symbol or list.

To show the actual list structure of the form 'A the functions (car)
and (cadr) are used which return the first and second elements
respectively of their list argument.

(car ''A)  ;=> quote    ; first element of the list
(cadr ''A) ;=> A        ; second element of the list

But if the quote occurs in tail of a cons it is printed as such:
'(A.'B)           ;=> (A quote B)
(cdr '(A.'B))     ;=> 'B

Vector Literals
---------------

Discussion: alps does not provide for array literals with rank greater
than 1. The only scalars are numeric scalars. There are vector
literals for the three value types: numbers, characters and
references. For the rest the reshape function can be used to reshape a
vector literal of any type into an array of the same type with more
than one dimension.

Numeric vector literal
----------------------

A sequence of zero or more numeric literals between square brackets
constitutes an numeric vector literal: 
Syntax: Numeric-Vector ::= "[" Space* [Number [Space+ Number]*] "]"
where   Space          ::= " " 

Examples:
[1 2 3]         ;=> [1 2 3]
(i 3)           ;=> [1 2 3]  ; i is the index generator function
(nump [])       ;=> t        ; is the null vector numeric ? 
(p [])          ;=> [0]      ; what is the shape of the null vector
(rank [])       ;=> 1        ; what is the rank of the null vector
(eq (p 0 0) []) ;=> t        ; is (p 0 0) the same as the null vector ?
(p [2 3] [1 2 3]) ;=>        ; create a 2x3 matrix from [1 2 3]
[1 2 3
 1 2 3]

Character vector literal
------------------------

These are exactly the same as ordinary character literals, that is a
sequence of zero or more characters enclosed in double quotes:
"<chr>*"  

(chrp "asdanbsfas")   ;=> t
(p "asdanbsfas")      ;=> [10]
(chrp "")             ;=> t           ; "" represents the null string. 
(p "")                ;=> [0]
(rank "")             ;=> 1
(eq (p 0 "hello") "") ;=> t  ;is (p 0 "Hello") the same as the null string ?
(rank (p 0 "hello"))  ;=> 1
(p [2 5] "hellopolly");=>       ; create a 2x5 character array
"hello
 polly"

Reference vector literal
------------------------

This is a vector of zero or more elements of any type whatsoever.
$[ <ref>+ ] 
<ref> elements can be any literal, e.g. numeric, character, symbol,
list, numeric vector literal or reference vector literal. 

(refp $[ nil A 'A "abc" 1 2 3]) ;=> t ; vector is of type reference (ref)

(p $[nil A 'A "abc" 1 2 3])     ;=> [7] ; 7 elements in vector

(p $[a bb ccc dddd eeee]) ;=> [5] ; 5 elements in vector all symbols

(explod $[a bb ccc dddd eeee]) ;=> (a bb ccc dddd eeee) ; convert to list
(refp $[]) ;=> t            ; $[] represents the null reference vector
(rank $[]) ;=> 1
(eq $[] (p 0 $[a b (d e) f])) ;=> t

Symbolic Expressions
--------------------

All interaction with the system is by means of symbolic expressions
which are the textual representation of data and code. There is no
distinction between programs and data, meaning that data can be
handled as code or code can be directly manipulated as data. A
symbolic expressions is also referred to as an S-expression or sexp.

An S-epression can be a simple Atomic-expression such as a symbol or
litteral or a list of zero or more Atomic-expressions and S-expressions.

In the informal BNF description of the S-expression syntax the
following conventions are used:

::= defines the left term by means of the terms on the right
|   is an or choice between terms
[]  terms or expressions enclosed in square braces are optional
To refer to the characters | [ and ] in definitions they are quoted
with single quotes e.g. '|'
* following a term means 0 or more occurrences of the term
+ following a term means 1 or more occurrences of the term
Adjacent Atomic-expressions must be separated by a space unless the second
term starts with a Special-ymbol.


<S-expression>::= <Atomic-expression> | ( <S-expression>* ) |
		  ( <S-expression> . <S-expression> )
				    
<Atomic-expression>::= <Symbol>            |
                       <Numeric-literal>   |
		       <Character-literal> |
		       <Reference-literal>

<Symbol>::= <Prefix>+<Suffix>* | <Special-symbol>

<Prefix>::= <Upper-alpha> | <Lower-alpha> | <Spec-char> | <Digits>

<Suffix>::= <Upper-alpha> | <Lower-alpha> | <Spec-char> | <Digits> | <Quote>

<Spec-char>::= !|#|$|%|&|*|+|-|.|/|<|=|>|?|@|^|_|'|'|~

<Special-symbol>::= "|`|:|,|;|\|(|)|'['|']'|{|}

<Quote>::= '

<Digits        ::= 0|1|2|3|4|5|6|7|8|9
<Upper-alpha>  ::= A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
<Lower-alpa>   ::= a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
<Non-printable>::= \A|\B|\C|\D|\E|\F|\G|\H|\I|\J|\K|\L|\M|\N|\O|\P|
		   \Q|\R|\S|\T|\U|\V|\W|\X|\Y|\Z|\[|\q|\]|\^|\_

<Numeric-literal>::= <Number> | <Complex-number> | '[' <Numeric-literal>* ']'

<Number>  ::= [<Sign>] <Digits> [[<Point>] <Digits>+]
              [<Exponent> [<Sign>] <Digits>+]
<Sign     ::= +|-
<Point>   ::= .
<Exponent>::= e

<Complex-number> ::= <Number>j<Number>

<Character-literal>::= " <Chars>* "
<Chars>::= <Printable> | <Non-printable>
<Printable>::= <Digits>    | <Upper-alpha> | <Lower-alpha> |
	       <Spec-char> | <Special-symbol>
		   
<Reference-literal>::= $'[' <S-expression>* ']'

<Numeric-vector-expression> { <S-expression>* }

<Reference-vector-expression> ${ <S-expression>* }

The formal qualifier for an S-expression is :sexp


Functions
---------

There is a large set of built-in functions which include most of the
standard APL\360 and Maclisp primitives. These are described in the
built-in function reference section. User defined functions are used
to extend the set of available functions.

The use of functions is very simple. In an evaluated S-expression the
first element is always the function and the rest are the arguments to the
function.

(<function> <argument>*)

There are two types of built-in function:

Type <subr>  functions that are passed evaluated arguments
Type <fsubr> functions that are passed their arguments un-evaluated


As an example of a built-in function of type <subr> consider the function
(list). (list) strings together each of its arguments into a list
which is the result it returns.
Assume the symbol A has a value of 1, then

(list A 2 (+ 2 A)) ;=> (1 2 3).

Each argument passed to a subr is evaluated before invoking the
function. If we evaluate

(list A B (+ 2 A))  => Unbound symbol: B

An error occurs because B has no value associated with it. If the
intent was to include the symbol B in the list it can be quoted in
the application:

(list A 'B (+ 2 A)) ;=> (1 B 3)

The arguments passed to a function of type <fsubr> are not evaluated
before it is invoked.  A built-in function of type <fsubr> may
evaluate none, some or all of its arguments as it requires. In some
lisp literature fsubr's are also called special forms.  For example
the built-in function (and) is an <fsubr>. The function (and) itself
evaluates each argument in turn until there are no more arguments or
until it finds an argument that evaluates to nil (i.e. the LISP
logical value for false).

If evaluation of all arguments is required for a boolean function we
can use the <subr> (list) to do the job and use the function (apply)
to apply the boolean operator to the evaluated list of arguments.

For example:
; assign A and C the value nil, and B the value 1
(setq A nil B 1 C nil) ;=> nil

(and A B (setq C (+ B 2))) ;=> nil ; since A has the value nil
C ;=> nil

Note the (setq) form was not evaluated because (and) is a <fsubr> that
only evaluates as many arguments as necessary to determine the result.
To force evaluation we can use (apply <fsubr> (list ...)):

(apply 'and (list A B (setq C (+ B 2)))) ;=> nil
C ;=> 3       ; the (setq C ..) form was evaluated
Note we had to quote the (and) function because (apply) is a <subr>.


User defined functions.

There are three kinds of user defined functions:

1: <expr> which are passed evalutated arguments. They have the form
   (lambda (<formal-parameters>) <Body>) and are defined using (de)
   (de <Name> (<formal-parameters>) <Body>)

2: <fexpr> which are passed their arguments un-evaluated and do not
   evaluate the result produced. They have the form
   (fexpr (<formal-parameters>) <Body>) and are defined using (df)
   (df <Name> (<formal-parameters>) <Body>)
   
3: <macro> which are also passed their arguments un-evaluated but
   *do* evaluate the result produced as an expression after unbinding
   its arguments.  They have the form
   (macro (<formal-parameters>) <Body>) and are defined using (dm)
   (dm <Name> (<formal-parameters>) <Body>)

Built-in function names can not be used as user defined functions.
However built-in function names can be used as variable symbols in all
situations except in the function position of an expression. In the
latter case the function applied is always the built-in one rather than
than the user defined one.

(defun myfun (car L) (car L)) returns the car of L
(car) is a built-in function.

(myfun 'len '(a b c)) ;=> a

To apply the value of the symbol car as a funtion

(defun myfun (car L) ((arg car) L))
(arg) just returns its (evaluated) argument.

(myfun 'len '(a b c)) ;=> 3

In the application of a user defined function of type <expr> each of
the parameters is evaluated and its value is bound to the respective
formal parameter. After each argument has been evaluated and bound the
body of the function is evaluated with those bindings in place.

For example:
; define a function Double that returns the double of its argument
(de Double (X) (+ X X)) ;=> Double
(Double 3) ;=> 6
(Double [1 2 3 4 5]) ;=> [2 4 6 8 10]
;; Note that numbers and constants evaluate to themselves
(a A 1)             ; Assign to A the value 1
(Double A)          ;=> 2
(Double (Double A)) ;=> 4 
; in this case the argument to the first is an expression
(de List3 (X Y Z) (list X Y Z)) ;=> List3
(List3 A 'B (Double A))         ;=> (1 B 2)
(List3 A 'B) => error Wrong number of arguments: function expects 3 but got 2
; Functions of type <expr> require exaclty the same number of
; arguments as they have formal parameters

If we want to define a function with variable number of parameters we
can use functions of type <fexpr> or <macro>.

; For example to define a function to list a variable number of values
(df List (X) (mapcar 'eval X)) ;=> List
(List A 'B)            ;=> (1 B)
(List A 'B (Double A)) ;=> (1 B 2)
; However if we were to change the definition of our function
; replacing X by A wherever X occurs in the definition:
(df List (A) (mapcar 'eval A))
;=> List
; unexpected results follow:
(List A 'B) ;=> ((A 'B) B)
; This is because A was bound to the list of parameters i.e. (A 'B)
; before the body of List was evaluated which effectively shadowed
; the previous binding of A to 1
(List A 'B (Double A)) => error Improper function argument:
arg 1 expected Number or Complex
(+ X X)
;; In this application the value of A passed to Double was the list
;; (A 'B) which is clearly not numeric

By making our user defined List function a <macro> which evaluates the
result only after the binding has been undone shows how to avoid this
difficulty. In general whenever (eval) is used in a <fexpr> it should
probably be recast as a <macro>.

(dm List (A) (append '(mapcar 'eval) (cons (cons 'quote (cons A nil)) nil)))
;=>List
(List A 'B)            ;=> (1 B)
(List A 'B (Double A)) ;=> (1 B 2)

One way to see what a <macro> will evaluate is simply to redefine
it as a <fexpr>. Because the system is a direct interpreter we can
examine the definition of a user defined function at any time by
evaluating the symbol of its name: 

List
;=> (macro (A) (append '(mapcar 'eval) (cons (cons 'quote (cons A nil)) nil)))

Thus it is possible to patch a macro to become a fexpr by replacing
the car (rplaca) of List by 'fexpr
(rplaca List 'fexpr) ;=> fexpr
; Now List is a fexpr
 List
;=> (fexpr (A) (append '(mapcar 'eval) (cons (cons 'quote (cons A nil)) nil)))
; Applying our patched List function:
(List A 'B (Double A)) ;=> (mapcar 'eval '(A 'B (Double A)))
; shows the function that will be evaluated
; It can be patched back to be a macro in the same way:
(rplaca List 'macro) ;=> macro
; Now List is a macro again
 List
;=> (macro (A) (append '(mapcar 'eval) (cons (cons 'quote (cons A nil)) nil)))

We can also show what the <macro> expands to which is what would be
evaluated using the user defined function (macroexpand) from prims.al:

(macroexpand List A 'B (Double A)) ;=> (mapcar 'eval '(A 'B (Double A)))

Note that as (mapcar) is a <subr> which has all its arguments
evaluated we need to quote them when constructing the expression to be
evaluated.

A useful advanced feature for macro construction, called quasiquoting,
can be used to simplify the construction of macros. Using this feature
we could define List as:

(dm List (A) `(mapcar 'eval ',A)) 
;=> List
(List 'a 'b 'c) ;=> (a b c)

See the section on quasiquoting for more details.


Built in function reference guide
---------------------------------

Each function is described as to its Syntax, Type, Arguments, Function
and Returns

Syntax:    defines the function name and its arguments
Type:      gives the type and class of the function
Arguments: gives the type and structure of each argument
Function:  describes what the function does
Returns:   describes the values returned by an application of the
 	   function


Standard type qualifiers for arguments have the following structure:

Type-qualifier ::= Type [Structure]

Type  ::= any  | sexp | list | num | chr | ref | fil | buf | tcb
any   ::= sexp | list | num  | chr | ref 
sexp  ::= Symbolic-expression
list  ::= ( Symbolic-expression* )
symb  ::= symbol
num   ::= numeric   atom
chr   ::= character atom
ref   ::= reference atom
ncr   ::= num | chr | ref
fil   ::= file object
buf   ::= buffer object
tcb   ::= task object     ;; internal task control block
wgt   ::= graphics widget

<structure>::= array | matrix | vector | singleton | scalar
array      ::= array with one or more dimensions
matrix     ::= array with exactly 2 dimensions
vector     ::= array with exactly 1 dimension
singleton  ::= <vector> of length 1 | <scalar>
scalar     ::= a single value with no dimensions (only exists for num)
any        :: array | scalar

For the examples in this section following variable bindings are
assumed to be in effect:

(setq A (i 5))          ;=> [1 2 3 4 5]
(setq I 1)              ;=> 1
(setq L '(a b (c d) e)) ;=> (a b (c d) e)

Basic lisp predicate functions
------------------------------

Test for atomicity
------------------
atom

Syntax:   (atom arg)
Type:     subr, predicate
Argument: arg:any 
Funtion:  Tests whether its single argument is an atom.
Returns:  t if arg is an atom, otherwise nil

Examples:
(atom A)   ;=> t
(atom I)   ;=> t
(atom L)   ;=> nil
(atom 'A)  ;=> t
(atom nil) ;=> t

Test for nil
------------
null

Syntax:   (null arg)
Type:     subr, predicate
Argument: arg:any
Funtion:  Tests whether its single argument is nil.
Returns:  t if arg is nil, otherwise =>nil

Example:
(null nil) ;=> t
(null A)   ;=> nil
(null L)   ;=> nil

Note: Most symbols for predicate functions terminate with the
      character "p" for predicate, however (atom) and (null) are
      exceptions due to the precedent set by historic lisp systems.

Test for cons cell
------------------
consp

Syntax:   (consp arg)
Type:     subr, predicate
Argument: arg:any
Funtion:  Tests whether its single argument refers to a cons cell.
Returns:  t if arg is a cons cell, otherwise =>nil

Example:
(consp A)   ;=> nil
(consp I)   ;=> nil
(consp L)   ;=> t
(consp nil) ;=> nil


Lisp structure construction
---------------------------

There are 5 built-in lisp structure construction primitives: (cons),
(acons), (list), (list*) and (pairlis).
(cons) creates a basic lisp structural element - the cons cell.
(list) creates a simple list from its arguments and
(pairlis) creates a list of dotted pairs from its two list arguments.
All lisp structure constructors can be defined using only (cons).

Creating a cons cell
--------------------
cons

Syntax:  (cons arg1 arg2)
Type:    subr, constructor
Arguments: arg1:any arg2:any
Funtion: Creates a cons cell initialising the head field to arg1 and the
         tail field to arg2.
Returns: New initialised cons cell

Example:
(cons 'A 'B)   ;=> (A . B)
(cons 'A nil)  ;=> (A)
(cons 'A (cons 'B (cons 'C nil))) ;=> (A B C)
(cons 'A L)    ;=> (A a b (c d) e)
(cons L nil)   ;=> ((a b (c d) e))

Creating a list
---------------
list

Syntax:    (list arg*)
Type:      subr, constructor
Arguments: arg:any
Function: Creates a list with as many cons cells as arguments. The
          head of each cons cell refers to the respective argument and
          the tail of each cons cell points to the next cons cell
          except for the last which contains the value nil.
	  (list arg1 arg2 ... <argn>) is equivalent to
	  (cons arg1 (cons arg2 (cons ... (cons <argn> nil)...)))
Returns:  The created list

Examples:
(list)                ;=> nil
(list 'A)             ;=> (A)
(list 'A 0 [1 2] L)   ;=> (A 0 [1  2] (a b (c d) e))

Creating a list with control over the last tail
-----------------------------------------------
list*

Syntax:    (list* arg+)
Type:      subr, constructor
Arguments: arg:any

 Function: This is a special variant of list. It creates a list with
           one fewer cons cells than the number of arguments given to
           it.  The head of each cons cell refers to the respective
           argument and the tail of each cons cell points to the next
           cons cell except for the last which references the last
           argument.

           (list* arg1 arg2 ... <argn>) is equivalent to
	   (cons arg1 (cons arg2 (cons ... (cons <argn-1>
	   <argn>)...)))

Returns: The created list. If list* is given only one argument that
         argument is returned.

Examples:
(list* 'A)                  ;=> A
(list* 'A 'B 'C)            ;=> (A B . C)
(list* 'A 0 [1 2] '(a b c)) ;=> (A 0 [1 2] a b c)

;; (list*) is useful for creating a list and appending another to
;; it efficiently
(list* 'A 0 [1 2] L) ;=> (A 0 [1  2] a b (c d) e)

Creating a list of pairs
------------------------
pairls

Syntax:    (pairlis arg1 arg2 [arg3])
Type:      subr, constructor
Arguments: arg1:list
	   arg2:list
	   arg3:any
	   
Function: (pairlis) is used to construct a so called association list
          from its two list arguments. An association list is list of
          dotted pairs. For each of the corresponding elements in
          arg1 and arg2 a dotted pair is created. The length of
          the list of dotted pairs is as long the list in arg1.  If
          the length of the list arg2 is shorter than arg1 nil is
          used for the missing elements in arg2. If given the third
          optional argument the created association list is prepended
          to it. If the third argument is not provided nil is used to
          terminate the association list. See also (assoc) which is
          used to lookup associations in an association list.
           
Returns: The created list.

Examples:
(pairlis '(a b c d) '(1 2 3 4)) ;=> ((a . 1) (b . 2) (c . 3) (d . 4))
(pairlis '(a b c d) '(1 2 3))   ;=> ((a . 1) (b . 2) (c . 3) (d))
(pairlis '(a b) '(1 2 3))       ;=> ((a . 1) (b . 2))
(pairlis '(a b c) '(1 2 3) '((d . 4) (e . 5))) ;=>
((a . 1) (b . 2) (c . 3) (d . 4) (e . 5))

Cons of Cons
------------
acons

Syntax: (acons arg1 arg2 arg3)
Type:   subr, constructor
Arguments: arg1:any
           arg2:any
           arg2:any
Function: It is the equivalent of (cons (cons arg1 arg2) arg3)
Returns: A structure of two cons cells where the car of the first cell
references the second cell whose car references arg1 and whose cdr
references arg2. arg3 is referenced by the cdr of the first cell.

Example:
(acons 'a 'b 'c)        ;=> ((a . b) . c)
(cons (cons 'a 'b) 'c)  ;=> ((a . b) . c)

+-------+
| . | c |
+-|-----+
  V
+-------+
| a | b |
+-------+

(caar (acons 'a 'b 'c)) ;=> a 
(cdar (acons 'a 'b 'c)) ;=> b
(cdr  (acons 'a 'b 'c)) ;=> c


Append lists to one another
---------------------------
append

Syntax: (append lst*)
Type: subr,constructor
Arguments: lst:list
Function: Each <lst> passed as an argument is copied to produce the
           resulting list with the exception of the list in the last
           argument which is not copied if there is more than one
           argument. If there is only one argument the result is
           simply a copy of that list.

Return: A single list comprised of each list passed in the arguments
        in order where the end of each list is joined to the beginning
        of the following list.

Examples:
(append)                               ;=> nil
(append L)                             ;=> (a b (c d) e)
(eq L (append L))                      ;=> nil       ; since a copy was made
(append L '(A B C))                    ;=> (a b (c d) e A B C)
(append '(A) '(B C) L)                 ;=> (A B C a b (c d) e)
(eq L (cdddr  (append '(A) '(B C) L))) ;=> t


Accessing cons elements
-----------------------
These functions access the heads and tails of cons cells.
Composition variants allow access up to the third level of
indirection. 



car

Syntax:   (car arg)
Type:     subr, accessor
Argument: arg:sexp

Function: Returns the head of the Cons Cell referred to by arg.
          If  arg is not a Cons Cell it returns nil.

cdr

Syntax:   (cdr arg)
Type:     subr, accessor
Argument: arg:sexp

Function: Returns the tail of the Cons Cell referred to by arg.
          If  arg is not a Cons Cell it returns nil.

caar

Syntax:   (caar arg)
Type:     subr, accessor
Argument: arg:sexp
Function: This is equivalent of (car (car arg))

cadr

Syntax:   (cadr arg)
Type:     subr, accessor
Argument: arg:sexp
Function: This is equivalent of (car (cdr arg))

cdar

Syntax:   (cdar arg)
Type:     subr, accessor
Argument: arg:sexp
Function: This is equivalent of (cdr (car <arg))

cddr

Syntax:   (cddr arg)
Type:     subr, accessor
Argument: arg:sexp
Function: This is equivalent of (cdr (cdr <arg))

The 3rd level accessor functions are also buitl-in:
caaar, caadr, caddr, cdddr, cadar, cdaar, cdadr

Historical remark: The functions (car) and (cdr) derive from the
instrunction set architecture of the first computer LISP was
implemented on back in 1958: the IBM 704. Announced in 1954 it was
IBM's most successful large scale, volume production, vacuum tube
based scientific computing system. Its type A instructions had two 15
bit fields called the address and the decrement. (car) stood for the
LISP funciton that extracted the "contents of the address part of
register number", and (cdr) for "contents of the decrement part of
register number". A register was 36 bits wide and was used to
represent a (cons) cell.

Basic Conditional expression
----------------------------
cond

Syntax:    (cond <clause>*)
Type:      fsubr, programme execution flow
Arguments: <clause> := (<predicate> <action>*)
	   <predicate>:sexp 
	   <action>:sexp
Function:  The <predicate> of each <clause> is evaluated until either
	   one <predicate> evaluates to t or there is no further
	   <clause>. The <action> expressions following the
	   <predicate> of the satisfied <clause> are evaluated in
	   order from left to right.
Returns:   If no <clause> is satisfied => nil
	   If there is no <action> term in the satisfied <clause> the
	   result of the evaluated <predicate> is returned.
	   Else the result of evaluating the last <action> in the
	   satisfied clause is returned.

Example:
(cond ((onep I) "true"))              ;=> "true"
(cond ((zerop I) "false"))            ;=> nil
(cond ((zerop I) "false") (t "true")) ;=> "true"
(cond ((zerop I) "false") ("true"))   ;=> "true"

Quoting values
--------------
quote

Syntax:    (quote arg) 
Alternate: 'arg
Type:      fsubr, special 
Arguments: arg:sexp
	   Any arguments after the first are ignored.
Function:  None, it is used to suppress the evaluation of arg when
           used in the argument list of an subr or expr.
Returns:   arg


Example:
(quote A)       ;=> A
(quote (a b c)) ;=> (a b c)
'(+ 1 2 3)      ;=> (+ 1 2 3)


Assigning values to symbols
---------------------------

There are 3 related functions for assigning values to symbols. They
are all fsubrs and differ only in the way they evaluate their
arguments.

(set) evaluates all its arguments
(setq) does not evaluate the symbol but does evaluate the value
expression. This is by far the most common form used and also has an
alternate function name: (a) for assignment.
(setqq) does not evaluate its arguments.

Assigning a value to a symbol both arguments evaluated
------------------------------------------------------
set

Syntax:    (set <symbol> <value>)
Type:      fsubr, binding
Arguments: <symbol>:sexp
	   <value>:sexp
Function: Assigns the result of evaluating the <value> expression
	  to the symbol resulting from the evaluation of the <symbol>
	  expression. 
Returns:   The result of the evaluation of the <value> expression.

Example:
(set (caddr '(A B C)) (i 3)) ;=> [1 2 3]
C ;=>  [1 2 3]

Assigning values to unevaluated symbols
---------------------------------------
setq
a

Syntax:    (setq <Symbol-Value-Pair>+)
Alternate: (a <Symbol-Value-Pair>+)
Type:      fsubr, binding
Arguments: <Symbol-Value-Pair> := <symbol> <value> 
	   <symbol>:symbol
	   <value>:sexp
Function:  Operates on each <Symbol-Value-Pair> in turn from left to
           right assigning the result of evaluating the <value>
	   expression to the <symbol> on its left. 
Returns:   The result of the evaluation of the last value expression.

Note: The synonym for setq which is the single letter a (for assign)
       is used in the default supplied #DX prompt-read-eval-print
       expression to allow assignment without printing the result
       as some results may be large arrays.

Example dialog:
(setq A 1 B 3) ;=> 3
(a C 3 D 4)    ;=> 4 (no result printed by default #DX)
(setq A 1 B 2) ;=> 2
(a C (p [100 100] (i 1e4))) 
;=> a 100x100 array (no result printed by default #DX)

Assigning an unevaluated value to an unevaluated symbol
-------------------------------------------------------
setqq

Syntax:    (setqq <symbol> <value>)
Type:      fsubr, binding
Arguments: <symbol>:symbol
	   <value>:any
Function:  Assigns to <symbol> <value>.
Returns:   <value>.

Examples:
(setqq A (+ 1 2 3)) ;=> (+ 1 2 3)
A ;=> (+ 1 2 3)

(setqq A [1 2 3]) ;=> [1 2 3]
A ;=> [1 2 3]

Creating a closure
------------------
fun

Syntax:    (fun <function>)
Type:      fsubr, binding
Arguments: The <function> argument must be a primitive, <expr>, <fexpr>
	   or macro expression or a symbol that is bound to one of
	   these.
Function:  Creates a closure which is a funarg triple
	   (fnarg <function> #<env>) where #<env> denotes that
	   captured binding environment at the time of the
	   application of fun. The <function> argument is evaluated
	   until an applicable function is found.
	   
Return:    Returns the funarg triple which can be used as a function to
	   apply <function> in the captured environment.

Example:

(a A 1 B 2)   ; set some global variables
(defun P () (list A B))) ;=> P ; function returns list of A and B
; make a closure of the local environment in the let expression
(setq PC (let ((A "hello") (B "polly")) (fun P)))  
;=> (fnarg (lambda nil (list A B))) #<env>)
(P)  ;=> (1 2)
(PC) ;=> ("hello" "polly")
(setq GC (fun (lambda () (list A B)))) ; capture global environment
;=> (fnarg (lambda nil (list A B)) #<env>)
(let ((A "Goodbye") (B "Sukey")) (GC)) ; evaluate GC in local environment
;=> (1 2)  ; returns values from global environment

Defining functions

Defining an expr
----------------
de

Syntax:    (de <name> <arglist> <body>)
Type:      fsubr, binding
Arguments: <name>:sym name of function to be defined.
           <arglist>:list a list of zero or more symbols corresponding
	   to the formal arguments.
	   <body>:<sexp>+ sequence of zero or more expressions

Function:  Binds a lambda expression with formal arguments <arglist>
           with <body> to the symbol <name> in the current binding
           environment. It is entirely equivalent to:
	   (setq <name> (cons 'lambda (cons <arglist> <body>))) apart
           from some error checking. 

Returns:   <name>

Examples:
(de Pyth (X Y) (sqrt (+ (sqr X) (sqr Y)))) ;=> Pyth
(Pyth 9 12) ;=> 15
; traditional lisp function for defining functions (included in prims.al)
(setq defun 'de)                ;=> de
(defun aPyth (X Y) (dist X Y))  ;=> aPyth
(aPyth [3 9] [4 12])            ;=> [5 15]

Defining a fexpr
----------------
df

Syntax:    (df <name> <arglist> <body>)
Type:      fsubr, binding
Arguments: <name>:sym name of the fexpr to be defined
           <arglist>:list a list of zero or more symbols corresponding
	   to the formal arguments.
	   <body> sequence of zero or more expressions

Function:  Binds a fexpr with the formal arguments <arglist>
           and body <body> to the symbol <name> in the current binding
           environment. It is entirely equivalent to:
	   (setq <name> (cons 'fexpr (cons <arglist> <body>))) apart
           from some error checking.

Returns:   <name>

Example:

Defining a macro
----------------
dm

Syntax:    (dm <name> <arglist> <body>)
Type:      fsubr, binding
Arguments: <name>:sym name of the macro to be defined
           <arglist>:list a list of zero or more symbols corresponding
	   to the formal arguments.
	   <body> sequence of one or more expressions

Function:  Binds a macro expression with formal arguments <arglist>
           with <body> to the symbol <name> in the current binding
           environment. It is entirely equivalent to:
	   (setq <name> (cons 'macro (cons <arglist> <body>))) apart
           from some error checking.

Returns:   <name>

Example:


Defining a function with lexical scoping
----------------------------------------
dc

Syntax: (dc (<name> <args>) <body>)
Type:      fsubr, binding
Arguments: <name>:sym name of the function to be defined
           <args>:sym* zero or more symbols corresponding to the
	   formal arguments.
	   <body>:sexp*  sequence of one or more  expressions

Function:  Binds a lambda expression with formal arguments <arglist>
           with <body> to the symbol <name> in the current binding
           environment. Furthermore it captures the current
           environment in a closure that is used whenever the function
           is invoked. This gives a Scheme-like behaviour.

Returns:    <name>

Example:
(a F "I am free")    ; assign a value to F in the current environment
(setq define 'dc)    ; Scheme syntax
(define (T X) (list F X))  ;=> T
(defun U (X) (list F X))   ;=> U
(defun V (F X) (F X))      ;=> V   ; occludes F with paramter
(V T 'Prometheus)          ;=> ("I am free" Prometheus)
; Note that T uses the defining environment to lookup the value of F
(V U 'Prometheus)          ;=> ((lambda (X) (list F X)) Prometheus)
; Note that U uses the dynamic environment to lookup the value of F

Defining a constant
-------------------
defconst

Syntax:     (defconst <name> <value>)
Type:       fsubr,binding
Arguments:  <name>:sym a variable symbol excluding built-in function names
            <value>:sexp expression

Function: The expression <value> is evaluated and the result assigned
          to the symbol <name> in the global environment. Other
          bindings of <name> in effect are not affected.  The symbol
          is marked as a constant variable symbol and may not be
          assigned values with set, setq, setqq or a. The value
          associated with name in the global environmenet can be
          changed with another invocation of (defconst). The symbol
          <name> is shadowed in the same way as any other symbols in
          the global environment.

Returns:    <name>

Example:
(defconst H '(hello polly))  ;=> H
H                            ;=> (hello polly)
(a H 'Sukey)                 ;=> ***ERROR***
;Invalid assignment target: constant: expected var symbol
(defun P (X) (let ((H '(bye bye sukey))) 
                (defconst H (list 'hello X)) (print H)))
;=> P
(P 'joe)  ;=> (bye bye sukey)
H         ;=> (hello joe)
(P 'fred) ;=> (bye bye sukey)
H         ;=> (hello fred)
(defun Q () (let (H) (a H "hello"))) ;=> Q
(Q) => ***ERROR***
;Invalid assignment target: expected var symbol

Applying a function to a set of  evaluated arguments
----------------------------------------------------
apply

Syntax: (apply function args+ last-arg)
Type: subr, evaluation
Arguments: function:<subr>|<fsubr>|<expr>|<fexpr>|<macro>
           args:sexpr
	   last-arg:lst

Function: Applies <function> to the evaluated arguments.
	  Each <arg> is passed as a separate argument to
          the <function>. Each element of <last-arg> is additionally
	  passed as a separate argument to <function>.

Returns: Result of applying <function> to the set of arguments.

Example:
(a X 1)
(apply '+ 1 (list 2 3 4)) ;=> 10
(apply '+ 1 (list X 3 4)) ;=> 9
(apply '+ (list X 3 4))   ;=> 8
(apply '(lambda (X) (+ X X))  (list X)) ;=> 2

Calling the evaluator
---------------------
eval

Syntax: (eval <expression> [<bindings>])
Type: subr, evaluation
Arguments: <expression>:sexpr
           <bindings>:association list of symbol-value pairs |
	              environment from a funarg triple (see (fun))

Function: Evaluates <expression>.
          If the <bindings> argument is not provided the evaluation
          uses the current bindings.
	  
	  If (null <bindings>) => t the evaluation takes place in the
	  global environment.

	  If <bindings> is an association list the the bindings of the
          association list are added to the current bindings before
          the expression is evaluated and the added bindings are
          removed afterwards. If any of the value bindings of the
          association list were modified during the evaluation of
          <expression> then these are reflected in the association
          list. Hence the association list structure of the
          association list should under no circumstances be
          manipluated in the <expression>. If the association list is
          not properly structured the result is unpredictable.

	  If <bindings> is an environment from a funarg triple, the
	  current bindings are undone down to the point where the
	  environment was captured. Then the bindings from the
	  environment are added before evalution <expression>. After
	  evaluation the bindings from the environment are removed and
	  all the bindings of the current environment are restored.
	  
Example:
(eval '(+ 1 2 3)) ;=> 6
(a X "hello")
(let ((X "bye")) X) ;=> "bye"
(let ((X "bye")) (eval 'X)) ;=> "bye"
(let ((X "bye")) (eval 'X nil)) ;=> "hello" ; evaluation in global env

(a A 2 B 3)
(eval '(+ A B)) ;=> 5
;; Make an association list E
(setq E (pairlis '(A B) '(5 6))) ;=> ((A . 5) (B . 6)) 
(eval '(+ A B) E) ;=> 11
(eval '(let () (a A 100) (+ A B)) E) ;=> 106 ;; modify binding of A
E ;=> ((A . 100) (B . 6)) ;; association list modified

;; create a funarg triple
(setq F (let ((A 1) (B 2) (C 3)) (fun '(lambda () (list A B C)))))
;=> (fnarg (lambda nil (list A B C)) #<env>)
(F) ;=> (1 2 3) ;; Usual use of funarg
(a A 2 B 3)
(eval '(+ A B)) ;=> 5
(eval '(+ A B) (caddr F)) ;=> 3 ;; Using captured environment
(eval '(+ A B)) ;=> 5
;; Modify captured environment
(eval '(let () (a A 100) (+ A B)) (caddr F)) ;=> 102
(F) ;=> (100 2 3)   ;; modified captured environment
(eval '(+ A B)) ;=> 5


Executing a list of forms with local variables
----------------------------------------------
let
let*

Syntax:    (let  Varlist Body)
	   (let* Varlist Body)		
Type:      fsubr, binding
Arguments: Varlist ::= ( Variable-Declaration* )
	   Variable-Declaration ::= Symbol | ( Symbol [S-Expression] )
	   Body ::= S-Expression*

Function:  When the let form is evaluated first each
	   Variable-Declaration is evaluated in turn. For (let) the
	   variables are bound to the environment only after every
	   Variable-declaration has been evaluated. For (let*) on
	   the other hand binding takes place progressively with each 
	   Variable-Declaration evaluated.

           In the evaluation of a Variable-declaration (Symbol
	   S-Expression) the result of evaluating the S-Expression is
	   bound to the Symbol. If there is no S-Expression nil is
	   bound to the Symbol. When the binding of a
	   Variable-Declaration has been added to the environment,
	   subsequent references to its <symbol> withing the scope of
	   the (let[*]) return the associated value.

	   Once every <variable declaration> has been evaluated and
	   bound to the environment each expression in the body is
	   evaluated in turn. For all <S-Expressions> except the last in
	   Body the only effect they can have on the computation
	   is through side effects such as the assigning of values to
	   variables.  When control exits the (let[*]) the <variable
	   declaration> bindings are undone and the environment is
	   restored to the same state as when the (let[*]) was
	   entered. Note assignments to free variables in body are not
	   undone.

Returns:  The value of evaluating the last <expression> is returned.
          If there are no <expressions> in the body nil is returned.

General programme execution flow
--------------------------------

Conditional expressions
-----------------------
The standard lisp conditional function (cond) is very general.
For convenience lisp also defines some more specific alternative
conditional functions. For each the equivalent (cond) construct is
also given.

If condition then else
----------------------
if

Syntax: (if <predicate> <true-expression> <else-expressions-list>)
Type:  fsubr, program execution flow
Arguments: <predicate>:sexp
           <true_expression>:sexp
	   <else-expression-list>:sexp*

Function: The <predicate> is evaluated and if the result is non-nil
	  the <true-expression> is evaluated and the result returned
	  as the value of the function.
	  If the <predicate> evaluates to nil the sexp's of the
	  <else-expression-list> are evaluated and the value of the
	  last evaluated sexp is returned as the value of the
	  function. If the <predicate> evaluates to nil and the
	  <else-expression-list> is empty, nil is returned.

cond form:  (cond (<predicate> <true-expression>)
                  (t <else-expression-list>))

Returns: see Function above.

Examples:
---------

(if t 'true) ;=> true
(if nil 'true) ;=> nil
(if nil 'true (print 1) (print 2) 'ok)
1
2
;=> ok

When condition then
-------------------
when

Syntax: (when <predicate> <predicate-true-expression-list>)
Type:  fsubr, program execution flow
Arguments: <predicate>:sexp
           <predicate_true_expression-list>:sexp*

Function: The <predicate> is evaluated and if the result is non-nil
	  the sexp's in the  <predicate_true_expression-list> are
	  evaluated.

cond form:   (cond (<predicate> <predicate-true-expression-list>))

Returns: If the <predicate> evaluates to non-nil the value of the
         last sexp evaluated in  <predicate_true_expression-list> is
         returned otherwise nil is returned.

Example
(when t (print 1) (print 2) 'ok)
1
2
;=> ok
(when nil (print 1) (print 2) 'ok) ;=> nil

Unless condition then
---------------------
unless

Syntax: (unless <predicate> <predicate-false-expression-list>)
Type:  fsubr, program execution flow
Arguments: <predicate>:sexp
           <predicate-false-expression-list>:sexp*

Function: The <predicate> is evaluated and if the result is nil
	  the sexp's in the  <predicate-false-expression-list> are
	  evaluated.
	  
cond form:  (cond (<predicate> nil)
                  (t <predicate-true-expression-list>))

Returns: If the <predicate> evaluates to nil the value of the
         last sexp evaluated in  <predicate-false-expression-list> is
         returned otherwise nil is returned.


Examples:
---------
(unless nil (print 1) (print 2) 'ok)
1
2
;=> ok

(unless t (print 1) (print 2) 'ok) ;=> nil

Looping constructs
------------------
These are convenience functions to facilitate porting of code from
procedural languages.

while
Syntax: (while <predicate> <body>)
Type: fsubr, program execution flow
Arguments: <predicate>:sexp
           <body>:sexp*

Function: While <predicate> evaluates to non-nil the sexp's of <body>
          are evaluated in order. When <predicate> evaluates to nil
	  the function returns.

Returns: If the <body> was evaluated the value of the last sexp in the
         body is returned otherwise it returns nil.

Examples:
---------
(let ((A 3)) (while (gt A 1) (prin0 'A) (print A) (a A (- A 1))))
A 3
A 2
;=> 1

(let ((A 3)) (while (gt A 3) (prin0 'A) (print A) (a A (- A 1)))) ;=> nil


repeat
Syntax: (repeat <predicate> <body>)
Type: fsubr, program execution flow
Arguments: <predicate>:sexp
           <body>:sexp*

Function: To start the sexp's of <body> are evaluated in order
	  followed by the evaluation of <predicate>. If it evaluates
	  to nil the sexp's are evaluated repeatedly until
	  <predicate> evaluates to non-nil at which point the function
	  returns.

Returns: If the body is not nil the value of the last sexp evaluated in
 	 the body is returned otherwise it returns t.

(let ((A 3)) (repeat (eq A 0) (prin0 'A) (print A) (a A (- A 1))))
A 3
A 2
A 1
;=> 0

(let ((A 3)) (repeat (eq A 3))) ;=> nil

Catch and Throw
---------------

This pair of functions can be used to return directly to the point of
the catch in the calling function from the corresponding throw in any
function in the call chain invoked by that calling function. This
avoids the need to test for specific return conditions in the functions
in the invoked chain of functions.

catch
Syntax: (catch <tag> <body>)
Type: fsubr, program execution flow
Arguments: <tag>:sym
           <body>:sexp+

Function: Associates the <tag> symbol with the the return point of the
          catch function, then the sexp's of <body> are evaluated in
          turn.
	  
Returns: If no (throw <tag> <exp>) is evaluated in the <body> the
	 the value of the last sexp in <body> is returned.
	 Otherwise if a (throw <tag> <exp>) is evaluated the result of
	 evaluating <exp> is returned.
	 
throw
Syntax: (throw <tag> <exp>
Arguments: <tag>:sym
           <exp>:sexp

Function: Evaluates <exp> and transfers control to the end of the
          catch with a corresponding <tag>. If no catch is found with a
          corresponding <tag> an error is signaled.

Returns: Does not return.

Examples:
---------
(defun Throw (X) (if X (throw 'a 'caught))) ;=> Throw
(catch 'a  (print 'hello) (Throw nil)  'bye)
hello
;=> bye

(catch 'a  (print 'hello) (Throw t)  'bye)
hello
;=> caught

Generating a user error
-----------------------
error

Syntax: (error <string>)
Type:   subr, control
Arguments: <string>:chr
Function:

Call with current continuation
------------------------------
cwcc

Syntax:    (cwcc <lambda-expression>)
Type:      subr, control
Arguments: The <lambda-expression> is any function taking a single
           argument.
Function:  The <lambda-expression> is invoked passing to it the
           current continuation at the point of call, i.e. the point
	   of continuation when the application of cwcc completes.
	   The argument passed to the <lambda-expression> is opaque
	   and should only be used as a function when invoking the 
	   continuation. All bindings in effect at the point of call 
	   are preserved with the continuation.
Returms:   The result returned by the application of the
           <lambda-expression>.

Example:
(a A 1 B 2 C 3 D 4 E 5)  ;=> 5 ; intialise some variables
(+ A B C D E)                               ;=> 15
(+ A B (cwcc '(lambda (X) (a K X)  C)) D E) ;=> 15
; Here the continuation was captured at the point of evaluating the
; third argument of + and assigned to the symbol K. As the lambda
; expression returned C the value of the whole expression is
; unchanged.
(K C)    ;=> 15
(a C 30) 
(K C)    ;=> 42
(a A 10) 
(K C)    ;=> 42   
; Changing the value of A has no effect since A had already been
; evaluated at the point of call
(a E 50)
(K C)    ;=> 87  ; (+ 1 2 30 4 50) => 87
(K -15)  ;=> 42

Catching errors
---------------
condition-case

Syntax: (condition-case <var> <body> <handlers>+)
handlers: (<error> <handler_body>)

Where error is one of:

unb_sym     "Unbound symbol"                  
inv_sym     "Invalid symbol"                  
inv_exp     "Invalid expression"              
inv_fun     "No such function defined"        
inv_numarg  "Wrong number of arguments"       
inv_funarg  "Improper function argument"      
dom_range   "Domain / Range error"            
sys_cor     "System tables corrupted"         
con_ass     "Invalid assignment target"       
not_imp     "Feature not implemented"         
bad_num     "Bad numeric constant"            
bad_str     "Bad string constant"             
bad_vec     "Bad vector"                      
no_files    "No available file attachments"   
inv_funame  "Not a proper function name"      
ios_err     "Input/Output/OS error"           
bad_file    "File/Directory not found"        
sys_par     "System parameter out of bounds"  
pgmr_inc    "Programmer incompetence detected"
user_err    "User defined error"              
user_int    "User interrupt"                  
sys_int     "System interrupt"                

unwind-protect

Syntax: (unwind-protect <bodyform> <unwindforms>+)


The prog feature
----------------

Discussion: This feature provides an imperative programming model which
resembles that of procedural languages such as Fortran, Pascal or C.
The lisp implementation however provides powerful constructs such as
non-local goto's, computed goto's and arbitrary return points which
can be convenient when exploring complex algorithms where there is a
need to escape directly from deeply nested call chains under specific
program determined conditions. Features such as (catch) and (throw) or
(unwind-protect) may provide the needed escape mechanism in certain
cases. The (prog[*]) construct is like the (let[*]) construct but
(prog[*]) provides additional control and exit mechanisms.


The prog construct
-----------------
prog
prog*

Syntax:    (prog  Varlist Body)
	   (prog* Varlist Body)		
Type:      fsubr, binding, program control
Arguments: Varlist ::= ( Variable-Declaration* )
           Variable-Declaration ::= Symbol | (Symbol [S-Expression])
	   Body       ::= Statement*
	   Statement  ::= [Label] Expression
	   Label      ::= Symbol
	   Expression ::= S-Expression

Function:  When the prog construct is evaluated first each
	   Variable-Declaration is evaluated in turn. For (prog) the
	   variables are bound to the environment only after every
	   Variable-declaration has been evaluated. For (prog*) on
	   the other hand binding takes place progressively with each 
	   Variable-Declaration evaluated.

           In the evaluation of a Variable-declaration 
	   (Symbol  S-Expression) the result of evaluating the S-Expression is
	   bound to the Symbol. If there is no S-Expression nil is
	   bound to the Symbol. When the binding of a
	   Variable-Declaration has been added to the environment,
	   subsequent references to its <symbol> withing the scope of
	   the (prog[*]) return the associated value.

	   Once every <variable declaration> has been evaluated and
	   bound to the environment the <expression> of each statement
	   is evaluated in turn. For all <statements> except the last
	   in the body or <statements> invoking (return) the only
	   effect they can have on the computation is through side
	   effects such as the assigning of values to variables.  When
	   control exits the (prog[*]) the <variable declaration>
	   bindings are undone and the environment is restored to the
	   same state as when the (prog[*]) was entered. Note
	   assignments to free variables in body are not undone.

Returns:  If a (return) form is evaluated the resulting value of that form is
	  returned. If control reaches the last statement the value of
	  its <expression> is returned.
          If there are no <statements> in the body =>nil


Examples:


Returning from a prog
---------------------
return

Syntax:    (return [Value])
Type:      subr, program control
Argument:  Value ::= S-Expression (optional)
Function:  Exits the innermost active (prog[*]) invocation. If there
           is no active (prog[*]) invocation an error is signaled.
Returns:   (eval Value) to the form invoking the innermost active
	   (prog[*]) construct.

Example:


Moving control about in prog contructs
--------------------------------------

go
--
Syntax:   (go <target>)
Type:     subr, program control
Argument: <target>:sexp :=> sym|ref
Function: Transfers control to the Expression part of the Statement
	  within the innermost active (prog[*]) construct
	  where (eq Label (eval <target>) => t
	  If no matching Label is found an error is signaled.
	  If (eq (eval <target>) $[]) => t then control simply passes to
	  the statement after the (go <target>) in the prog[*] body.
	  
Returns:   none

Note: The (go) form can only be evaluated within the (dynamic)
      scope of a prog.  Difference with Lisp1.5: The argument is
      evaluated. So in Lisp1.5 where we would write (GO A) in alps we
      have to write (go 'A).  In alps (go) is a subr in order to more
      closely emulate the computed goto semantics of the APL goto
      operator (right arrow).

example: Adapted from [Lisp1.5M]
;
; Iterative program to compute the length of a list
;
(defun LENGTH (L)  
  (prog (U V) 
	 (setq V 0) 
	 (setq U L) 
A	 (cond ((null U)  (return  V))) 
	 (setq U (cdr U)) 
	 (setq V (+ 1 V)) 
	 (go 'A)))
;=> LENGTH

(LENGTH '(A B C)) ;=> 3

;
; Using more modern constructs the same prog could be defined as:
;
(defun Length (L)
  (prog ((V 0))
A   (unless L (return V))
    (a L (cdr L) V (+ 1 V))
    (go 'A)))
;=> Length
(Length '(a b c d e f)) ;=> 6

;
; Using while does not need (prog)
;
(defun Len (L)
  (let ((V 0))
       (while L
              (a L (cdr L) V (+ 1 V)))))
;=> Len
(Len '(a b c d e f)) ;=> 6

;
; Typical LISP recursive variant
;

(defun LenR (L)
     ((label R lambda (L N) (cond ((null L) N) (t (R (cdr L) (+ N 1)))))
      L 0))  ;; initial values for R
;=> LenR      
(LenR '(a b c d e f)) ;=> 6


;
; Contrived computed goto example
;
(defun ComputedGoto (X)
  (prog (R (#IO 1) (Home 'Out))
  	(if (or (lt X 1) (gt X 3)) (return "rubbish"))
	(go (aref $[L1 L2 L3] X)) ; computed goto
	(error "never reached")
   L1   (a R 'one)
	(go Home)
   L2   (a R 'two)
	(go Home)
   L3   (a R 'three)
   Out  R))
=> ComputedGoto

(mapcar ComputedGoto '(0 3 1 2 4)) => ("rubbish" three one two  "rubbish")
	
;
; Typical APL usage using compress (k) on statement label
;
(defun Gcd (V) ;; Greatest common divisor APL style
  (prog (R) 
    LOOP
    (go (k (< 1 (p (a V (k (* (a V (cat (| (a R (r 'f V)) V) R))) V))))
	   $[LOOP]))
    R)) 
=> Gcd
; while the shape of V is greater than 1 the reference vector $[LOOP]
; is not compressed. When the shape of V is 1 then k compresses out
; the single element of $[LOOP] making the empty reference vector $[]
; and the result R is returned.
; (go $[]) is equivalent to a nop (no operation).


(Gcd [30 75 105]) ;=> 15
(Gcd [26 91])     ;=> 13


Type predicates
---------------

Discussion:
Type predicates can be used to check the type of their argument. There
is no value domain for type values in alps, so to test the type of a
data item we need to test for each of the types using the type
predicates. For example:
(defun type (X) 
    (cond ((listp X)   "list") ; cons cell or nil
	  ((primp X)   "primitive")
	  ((symbolp X) "symbol")
	  ((refp X)    "ref") 
	  ((nump X)    "num") 
	  ((cpxp X)    "cpx") 
	  ((chrp X)    "chr") 
	  (t           "?")))

(type 1)        ;=> "num"
(type "asd")    ;=> "chr"
(type $[])      ;=> "ref"
(type '(a s d)) ;=> "list"
(type nil)      ;=> "list"
(type 'asd)     ;=> "symbol"
(type 'list)    ;=> "primitive"
(type 1j0)      ;=> "cpx"

The three basic types are numeric, character and reference which are
tested for with (nump), (chrp) and (refp) respectively. The basic lisp
type predicates (atom), (null) and (consp) are documented separately
above. (symbolp) tests whether its argument is a symbol and (primp)
tests whether its argument is the symbol of a primitive function or in
other terms a built-in function. If an atomic argument is not a symbol
it is a constant with the exception of the two special symbols t and
nil which are both symbols and constants. (listp) and (nlistp) are
shorthand composite type predicates.

Testing for list
----------------
listp

Syntax: (listp arg) => res
Type:     subr, type predicate
Argument: arg:any

Function: If arg is a cons cell or arg is null the result is t
          otherwise it is nil. Equivalent to
	   (or (consp arg) (null arg)) 

Returns: res where res is either t or nil

Testing for not list
--------------------
nlistp

Syntax: (nlistp arg) => res
Type:     subr, type predicate
Argument: arg:any

Function: It is a built-in function for (not (listp arg)). If arg
          is a cons cell or arg is null the result is nil otherwise
          it is t. Equivalent to
	  (and (atom arg) (not (null arg)))

Returns: res where res is either t or nil

Testing for numeric
-------------------
nump

Syntax: (nump arg) => res
Type:     subr, type predicate
Argument: arg:any

Function: If arg is a numeric scalar or array the result is t
	  otherwise it is nil. 

Returns: res where res is either t or nil

Testing for complex
-------------------
nump

Syntax: (cpxp arg) => res
Type:     subr, type predicate
Argument: arg:any

Function: If arg is a complex scalar or array the result is t
	  otherwise it is nil. 

Returns: res where res is either t or nil

Testing for character
---------------------
chrp

Syntax: (chrp arg) => res
Type:     subr, type predicate
Argument: arg:any

Function: If arg is a character array the result is t
	  otherwise it is nil. 

Returns: res where res is either t or nil

Testing for reference
---------------------
refp

Syntax:   (refp arg) => res
Type:     subr, type predicate
Argument: arg:any

Function: If arg is a reference array the result is t
	  otherwise it is nil. 

Returns: res where res is either t or nil

Testing for symbol
------------------
symbolp

Syntax:   (symbolp arg) => res
Type:     subr, type predicate
Argument: arg:any
Function: If arg is a symbol the result is t
	  otherwise it is nil. 

Returns: res where res is either t or nil

Testing for primitive
---------------------
primp

Syntax:   (primp arg) => res
Type:     subr, type predicate
Argument: arg:any
Function: If arg is the symbol of a built-in primitve the result is t
	  otherwise it is nil. 

Returns: res where res is either t or nil

Value predicates
----------------

Discussion: The value predicates provide a means for translating from
certain APL values to the lisp logical constants. These functions
require either a scalar or singleton vector or array. The APL reduce
operator can by used to reduce a vector or array to a scalar.

Testing for zero
----------------
zerop

Syntax:   (zerop arg) => res
Type:     subr, value predicate
Argument: arg:numeric singleton
          #CT comparison tolerance

Function: If arg is zero the result is t otherwise it is nil.

Returns: res where res is either t or nil

Note: No number is within #CT of 0. (see #CT)

Examples:
(zerop 0)                      ;=> t
(zerop 1e-240)                 ;=> nil
(zerop (> (- (| 1e-240) #CT))) ;=> t ;; test whether a number is nearly 0
(zerop (> (- (| 1e-13)  #CT))) ;=> t
(zerop (> (- (| 1e-12)  #CT))) ;=> nil
#CT                            ;=> 1e-13
(zerop [0])                    ;=> t
(zerop 1.2)                    ;=> nil
(zerop 1e-12)                  ;=> nil
(zerop [0 1])    =>
Domain / Range error: argument can have only one element
(zerop (r 'v (<>  0 [0 1 0]))) ;=> nil   ; test for all zeros
(zerop (r 'v (<>  0 [0 0 0]))) ;=> t
(zerop (r '^ (<>  0 [1 1 1]))) ;=> nil   ; test for at least one zero
(zerop (r '^ (<>  0 [1 0 1]))) ;=> t

Testing for unity
-----------------
onep

Syntax:   (onep arg) => res
Type:     subr, value predicate
Argument: arg:numeric singleton

Function arg is compared to one using the comparison tolerance (see
         #CT). If arg is one the result is set t otherwise it is nil.

Returns: res where res is either t or nil

Examples:
(onep 1)           ;=> t
(onep (+ 1 1e-40)) ;=> t
(onep [1])         ;=> t
(onep 1.2)         ;=> nil
(onep (+ 1 1e-12)) ;=> nil
(onep [0 1]) ;=> Domain / Range error: argument can have only one element
(onep (r '^ (= 1 [0 1 0]))) ;=> nil   ; test for all ones
(onep (r '^ (= 1 [1 1 1]))) ;=> t
(onep (r 'v (= 1 [0 0 0]))) ;=> nil   ; test for at least one one
(onep (r 'v (= 1 [1 0 1]))) ;=> t



Testing for oddness
-------------------
oddp

Syntax:   (oddp arg) => res
Type:     subr, value predicate
Argument: arg:numeric singleton

Function: arg is tested whether the remainder upon division by two
          is one using the comparison tolerance (see #CT). If the
          remainder is one the result is t otherwise it is nil.

Returns: res where res is either t or nil

Examples:
(oddp 1)           ;=> t
(oddp (+ 1 1e-40)) ;=> t
(oddp [1])         ;=> t
(oddp 2)           ;=> nil
(oddp 1.2)         ;=> nil
(oddp (+ 1 1e-12)) ;=> nil
(oddp [0 1]) ;=> Domain / Range error: argument must have only one element
(onep (r '^ (= 1 (| 2 [1 2 3])))) ;=> nil   ; test for all odd (note using onep)
(onep (r '^ (= 1 (| 2 [1 5 3])))) ;=> t
(onep (r 'v (= 1 (| 2 [2 4 6])))) ;=> nil   ; test for at least one odd 
(onep (r 'v (= 1 (| 2 [2 4 5])))) ;=> t

Testing for eveness
-------------------
evenp

Syntax:   (evenp arg) => res
Type:     subr, value predicate
Argument: arg:numeric singleton

Function: arg is tested whether the remainder upon division by two
          is zero using the comparison tolerance (see #CT). If the
          remainder is zero the result is t otherwise it is nil.

Returns: res where res is either t or nil

Examples:
(evenp 2)           ;=> t
(evenp (- 2 1e-40)) ;=> t        ;#CT 1e-13
(evenp [2])         ;=> t
(evenp 1)           ;=> nil
(evenp 2.1)         ;=> nil
(evenp (+ 2 1e-12)) ;=> nil      ;#CT 1e-13
(evenp (+ 2 1e-16)) ;=> t        ;#CT 1e-13
(evenp [0 1]) ;=> Domain / Range error: argument must have only one element
(onep (r '^ (= 0 (| 2 [1 2 3])))) ;=> nil  ; test for all even (note using onep)
(onep (r '^ (= 0 (| 2 [2 4 6])))) ;=> t
(onep (r 'v (= 0 (| 2 [1 3 5])))) ;=> nil    ; test for at least one even 
(onep (r 'v (= 0 (| 2 [1 2 3])))) ;=> t

Converting between APL and Lisp logical values
----------------------------------------------

Conversion from apl to lisp logical values can be done using the lisp
value predicate (onep)

(onep 1)  ;=> t
(not t)   ;=> nil
(not nil) ;=> t
(not 3)   ;=> nil
(zerop 3) ;=> nil
(not 0)   ;=> nil
(zerop 0) ;=> t

To convert a lisp logical constant, llc, to the equivalent apl logical
constant the follwing expression can be used:

(- (ind $[nil] $[llc]) #IO)

For example:

(- (ind $[nil] $[nil t 1 "asd"]) #IO) ;=> [0 1 1 1]

; $[nil t 1 "asd"] is equivalent to $[nil t t t]
; #IO is the index origin which can be 0 or 1.

Lisp Logical operators
----------------------

Logical and
-----------
and 

Syntax:    (and arg*)
Type:      fsubr, predicate operator
Arguments: arg:any
Function: Evaluates each argument in turn until a nil result occurs
           or all the arguments have been evaluated.
Returns:   t if all arguments are non-nil else it returns nil
Note: Evaluation of the arguments stops at the first null argument

Logical or
----------
or

Syntax:    (or arg*)
Type:      fsubr, predicate operator
Arguments: arg:any
Function: Evaluates each argument in turn until a non-nil result occurs
           or all the arguments have been evaluated.
Returns:   t if one or more of its are non-nil else it returns nil
Note: Evaluation of the arguments stops at the first non-nil argument

Logical not and
---------------
nand

Syntax: (nand arg*)
Type: fsubr, predicate operator
Arguments: arg:any
Function: Returns  t if any arguments are nil else if all arguments
          are not nil it returns nil
Note: Evaluation of the arguments stops at the first null argument

(nand t t t t t t t t (print "hello"))   ;=> nil
"hello"

(nand t t t t t nil t t (print "hello")) ;=> t

Logical not or
---------------
nor

Syntax: (nor arg*)
Type: fsubr, predicate operator
Arguments: arg:any
Function: Returns nil if any arguments are t else if all arguments
          are nil it returns t
Note: Evaluation of the arguments stops at the first non-nil argument


Lisp dyadic predicates
----------------------

Discussion:

Lisp dyadic predicates test for equality and relations between
<entities> returning values in the range of the lisp logical constants
i.e. t and nil. These are different from the APL predicates which
return values in the range of the APL logical constants which are 0
and 1.  Another difference is in the way they treat character
variables and symbols. The APL dyadic predicates always treat symbols
as character vectors.  Note that all symbol literals for a given name
resolve to the same object. The same is true for singleton character
vectors.

For example:
  (eq 1 1)         ;=> t
  (=  1 1)         ;=> 1
  (eq [1] [1])     ;=> nil
  (=  [1] [1])     ;=> [1]
  (eq  "c" "c")    ;=> t
  (eq  'c  "c")    ;=> nil ; symbol and character array not same object
  (=   'c  "c")    ;=> [1]
    ;;; apl dyadic primitives do not distinguish between symbols and
    ;;; character vectors
  (eq "abc" "abc") ;=> nil
  (=  'abc  "abc") ;=> [1 1 1]
  (eq [1 2] [1 2]) ;=> nil
  (=  [1 2] [1 2]) ;=> [1 1]
However for convenience alps also defines (eql)
  (eql 'c  "c")     ;=> t
  (eql 'abc "abc")  ;=> t
  (eql "abc" "abc") ;=> t
  (eql [1 2] [1 2]) ;=> t

Testing for equality
--------------------

Discussion:

There three lisp primitives for testing the equality of two
objects. They are: (eq), (eql) and (equal), each with differing
semantics:

(eq) performs a simple and efficient comparison that tests whether
its arguments refer to the same object, that is they refer to the same
zone of storage representing the object. Only for scalar numeric arguments
will it test whether the two object have the same value if they do not
refer to the same object.

(eql) goes a bit deeper in that for array arguments it will test for
equality on an element by elmenent basis using (eq). For list arguments
however, it behaves the same way as (eq).

(equal) on the other hand, will recursively test each of the elements
of list arguments for equality on an element by element basis. If an
element is a list it will use (equal) to compare it with the
corresponding element in the other list. If the elements are arrays it
uses (eql).

If two objects are (eq) then they are also (eql) and (equal). 

If two objects are (eql) they are also (equal). 

If two objects are (equal) they are not necessarily (eql) or (eq). 

If two ojects are (eql) they are not necessarily (eq).

In summary (eq) simply compares its arguments without traversing their
structure. (eql) traverses only array arguments but does not go into
lists. (equal) fully traverses the list and array structures in its
arguments. 

Object equality
---------------
eq

Syntax: (eq arg1 arg2)
 Where arg1 and arg2 are of any type.

Type: subr, lisp relational operator

Function: For all cases except scalar arguments and character
	  singletons, eq tests whether the object referred to by
	  arg1 is the *same* object as that refered to by
	  arg2. For scalar arguments the comparison is made between
	  the value of the arguments using the comparison tolerance
	  (see #CT). All symbols, null vectors and character
	  signletons have a single unique representation in the
	  system thus they are always (eq) no matter how they are
	  referenced.

Returns:  t if arg1 is (eq) to arg2 else nil.

Examples:

(eq 'abc  'abc)      ;=> t
(eq "abc"  'abc)     ;=> nil
(eq "abc" "abc")     ;=> nil
(setq A "abc")       ;=> "abc"
(setq B A)           ;=> "abc"
(eq A B)             ;=> t
(eq [] [])           ;=> t  (numeric null vector)
(eq "" "")           ;=> t  (character null vector)
(eq $[] $[])         ;=> t  (reference null vector)
(eq "A" (chr 65))    ;=> t
(eq "q" (getc))      ;=> t if the character <q> was read by (getc)
(eq [1 2 3] [1 2 3]) ;=> nil
(eq 1 1)             ;=> t
(eq 1 [1])           ;=> nil
#CT                  ;=> .00001
(eq 1 1.0001)        ;=> nil
(eq 1 1.00001)       ;=> t
(eq 1 .99998)        ;=> nil
(eq 1 .999999)       ;=> t

Not eq
------
ne

Syntax: (ne arg1 arg2)
 Where arg1 and arg2 are of any type.

Type: subr, lisp relational operator

Function: Returns t if arg1 is not eq to arg2 else nil. The implementation
	   is equivalent to (not (eq arg1 arg2))

Vector equality
---------------
eql

Syntax: (eql arg1 arg2)
  Where arg1 and arg2 are of any type.

Type: subr, lisp relational operator

Function: If the arguments are of type numeric, character or
           reference and of the same type the comparison proceeds on
           an element by element basis regardless of the shape of the
           arguments. For numeric arguments the comparison tolerance
           is used (see #CT). For reference arguments if the elements
           refer to the same object they are considered to be eql.

Returns:   Returns t if they refer to the same lisp object.
	   For numeric, character or reference arguments returns t if
           all their corresponding elements are (eq) else nil.

Compatibility Note:     
	   Emacs eql does not equate symbols with character vectors -
           Emacs: (eql 'a "a") => nil ;  alps: (eql 'a "a") => t
	   Emacs considers scalars and unit vectors as not (eql) -
	   Emacs: (eql 1 [1]) => nil  ;  alps: (eql 1 [1]) => t
	   Emacs eql does not compare the contents of vectors
	   	  Emacs: (eql [1 2 3] [1 2 3])  => nil
         	  alps:  (eql [1 2 3] [1 2 3])  => t
           Emacs eql does not compare the contents of strings
	   	  Emacs: (eql "asd" "asd")  => nil
         	  alps:  (eql "asd" "asd")  => t
          
Examples:

(equal $[a (a b c) c] $[a (a b c) c]) ;=> t   ; equal digs into lists
(eql   $[a (a b c) c] $[a (a b c) c]) ;=> nil ; eql does not
(setq L '(a b c (d e) f))   ;=> '(a b c (d e) f)
${'a L 'c}                  ;=> $[a (a b c (d e) f) c]
(eql ${'a L 'c} ${'a L 'c}) ;=> t ; L is a list and it is the same object
(eql $[1 b cd] $[1 b cd])   ;=> t ; scalar and symbols
(eql $["abc" d ef] $["abc" d ef]) ;=> nil 
     ;;; "abc" are different objects in the reference vector arguments
     ;;; however
(equal $["abc" d ef] $["abc" d ef]) ;=> t 
       ;;; Since equal compares the values of the reference objects 
       ;;; not just the references.
(eql $[a b] $[a b])               ;=> t
(eql $["a" "b"] $["a" "b"])       ;=> t
(eql $["ab" "b"] $["ab" "b"])     ;=> nil
     ;;; eql compares the elements in the reference arrays using (eq)

List and vector element equality
--------------------------------
equal

Syntax: (equal arg1 arg2)
  Where arg1 and arg2 are of any type.

Type: subr, lisp relational operator

Function: If the arguments are of type numeric, character or
           reference and of the same type the comparison proceeds on
           an element by element basis. For numeric arguments the
           comparison tolerance is used (see #CT). For reference
           arguments the relational operator (equal) is used as
           elements can also be lists. If the arguments are lists each
           element in arg1 is compared to its corresponding element
           in arg2 using (equal). 

Returns:   For list arguments returns t if all their corresponding
           atoms are (equal) else nil.
	   For numeric, character or reference arguments returns t if
           all their corresponding elements are (equal) else nil.


Compatibility Note:     
	   Emacs does not equate symbols with character vectors -
           Emacs: (equal 'a "a") => nil ;  alps:  (equal 'a "a") => t
	   However -
 	   Emacs: (eq 'a "a") => nil    ;  alps:  (eq 'a "a") => nil
	   Emacs considers scalars and unit vectors as not (equal) -
	   Emacs: (equal 1 [1]) => nil  ;  alps:  (equal 1 [1]) => t
	   However - 
	   Emacs: (eq 1 [1]) => nil     ;  alps:  (eq 1 [1]) => nil
	   Common Lisp equal on vectors does not compare element by
	   	  element, it has yet another predicate (equalp)
            	  CL:    (equal #(1 2 3) #(1 2 3))  => NIL
		  CL:    (equalp #(1 2 3) #(1 2 3)) => T
		  Emacs: (equal [1 2 3] [1 2 3]) =>t
		  Alps:  (equal [1 2 3] [1 2 3]) =>t
	  
Examples:

(equal 'abc "abc")       ;=> t
(equal "abc" "abc")      ;=> t
(equal [1 2 3] [1 2 3])  ;=> t
(equal 1 [1])            ;=> t

Not equal
---------
nequal

Syntax: (nequal arg1 arg2)
 Where arg1 and arg2 are of any type.

Type: subr, lisp relational operator

Function: Returns t if arg1 is not (equal) to arg2 else nil. 
	   It is equivalent to (not (equal arg1 arg2))


Less than
---------
lt

Syntax: (lt arg1 arg2)
  Where arg1 and arg2 are numeric or character atoms of the same
  type. The comparison tolerance is used for numeric arguments (see #CT).


Type: subr, lisp relational operator

Function: The comparison is made on an element by element
           basis. Where the number of elements in arg1 and arg2
           differ, missing elements are taken to have a value lower
           than the lowest element of the type. The shape of the
           arguments is not taken into account.

Returns:  t if all elements in arg1 are less than or equal to the
	  their corresponding elements in arg2 and at least one
	  element in arg1 is less than its corresponding element in
	  arg2 else the result is nil.

Examples:

(lt 1 2) => t
(lt [1 2 3 3] [1 2 3 4]) => t
(lt [1 2 3 4] (p [2 2] [1 2 3 4])) => nil
(lt [0 2 3 4] (p [2 2] [1 2 3 4])) => t

(lt "abcd" "abce") => t
(lt "abcd" "abc")  => nil
(lt "abc" "abcd")  => t
(lt 'Abc "abc")    => t

Less than or equal
------------------
le

Syntax: (le arg1 arg2)
 
  Where arg1 and arg2 are numeric or character atoms of the same
  type.  The comparison tolerance is used for numeric arguments (see
  #CT).

Type: subr, lisp relational operator

Function: The comparison is made on an element by element
           basis. Where the number of elements in arg1 and arg2
           differ, missing elements are taken to have a value lower
           than the lowest element of the type. The shape of the
           arguments is not taken into account.

Returns:  t if all elements in arg1 are less than or equal to the
	  their corresponding elements in arg2 else the result is nil.

Examples:

(le 1 2) => t
(le [1 2 3 3] [1 2 3 4]) => t
(le [1 2 3 4] (p [2 2] [1 2 3 4])) => t
(le [0 2 3 4] (p [2 2] [1 2 3 4])) => t
(le [2 2 3 4] [1 2 3 4]) => nil

(le "abcd" "abcd") => t
(le "abcd" "abce") => t
(le "abcd" "abc")  => nil
(le "abc" "abcd")  => t
(le 'Abc  "abc")   => t

Greater than or equal
---------------------
ge

Syntax: (ge arg1 arg2)
 
  Where arg1 and arg2 are numeric or character atoms of the same
  type.  The comparison tolerance is used for numeric arguments (see
  #CT).

Type: subr, lisp relational operator

Function: The comparison is made on an element by element
           basis. Where the number of elements in arg1 and arg2
           differ, missing elements are taken to have a value lower
           than the lowest element of the type. The shape of the
           arguments is not taken into account.

Returns:  t if all elements in arg1 are greater than or equal to the
	  their corresponding elements in arg2 else the result is nil.

Examples:
(ge 2 1)                           => t
(ge [1 2 3 4] [1 2 3 4])           => t
(ge [1 2 3 3] (p [2 2] [1 2 3 4])) => nil
(ge [1 2 3 4] [1 2 3 4 -1]))       => nil
(ge [1 2 3 4 0] [1 2 3 4 0])       => t
(gt [1 2 3 4 0] [1 2 3 4 1])       => t

(ge "abcd" "abca") => t
(ge "abcd" "abc")  => t
(ge "abc" "abca")  => nil
(ge "abc" 'aba)    => t

Greater than
------------
gt

Syntax: (gt arg1 arg2)
  Where arg1 and arg2 are numeric or character atoms of the same
  type. The comparison tolerance is used for numeric arguments (see #CT).

Type: subr, lisp relational operator

Function: The comparison is made on an element by element
           basis. Where the number of elements in arg1 and arg2
           differ, missing elements are taken to have a value lower
           than the lowest element of the type. The shape of the
           arguments is not taken into account.

Returns:  t if all elements in arg1 are greater than or equal to the
	  their corresponding elements in arg2 and at least one
	  element in arg1 is strictly greater than its corresponding
	  element in arg2 else the result is nil. 


Examples:
(gt 2 1) => t
(gt [1 2 3 4] [1 2 3 4]) => nil
(gt [1 2 3 4] (p [2 2] [1 2 3 4])) => nil
(gt [1 2 3 4] [1 2 3 4 -1]))   => nil
(gt [1 2 3 4 1] [1 2 3 4 0])   => t

(gt "abcd" "abca") => t
(gt "abcd" "abc")  => t
(gt "abc" "abca")  => nil
(gt "abc" 'aba)    => t


List processing
---------------

Testing whether an element is a member of a list. There are two
functions that can be used: (memq) and (member). The former tests for
membership using (eq) which is more effiecient while the latter uses
(equal). See the discussion on "Testing for equality".

Quick Member
------------
memq

Syntax: (memq element set)
Type: subr, list processing
Arguments: element:any
           set:lst
Function: Searches the list <set> for the first car that is (eq) to <element>

Returns: If <element> is found in <set> (memq) returns a reference to
          the remainder of <set> of which <element> is the first
          element. Otherwise it returns nil.


Member
------
member

Syntax: (member <element> <set>)
Arguments: <element>:<any>
  	   <set>:list
Type: subr, list processing

Function: Searches the list <set> for the first car that is (equal) to <element>

Returns: If <element> is found in <set> (member) returns a reference to
          the rest of <set> of which <element> is the first
          element. Otherwise it returns nil.

Position of an sexpr in a list
------------------------------
pos

Syntax: (pos <element> <set>)
  Where <element> is an atom or list
  and <set> is a list.
Type: subr, list processing

Function: Searches the list <set> for the first car that is (equal) to
          <element> counting the elements skipped.

Returns: If <element> is found in <set> (pos) returns a scalar
          corresponding to the count of elements skipped.
	  Otherwise it returns [].

Note: This is not compatible with (position) in common Lisp which
returns nil if <element> does not occur within <set>. Since [] is
numeric the result of (pos) can be used with arithmetic functions
without having to deal with the special case of nil. (see definition
of (eib) below).

(pos 'a '(a b c d e)) ;=> 0
(pos 'e '(a b c d e)) ;=> 4
(pos 'f '(a b c d e)) ;=> []
(pos '(a b c) '(a b (a b c) d)) ;=> 2
;; if '(A B C D E F) are symbolic names for bits 0 through 5
;; (eib) calculates the inclusive or of the bit masks
(df eib (X)
    (r '+ (exp 2 (implod (mapcar '(lambda (Y) (pos Y '(A B C D E F))) X)))))
(eib A C F)    ;=> 37
(eib A C F Z)  ;=> 37


Testing for subset
------------------
subset

Syntax: (subset arg1 arg2)
Type: subr, list processing
Arguments: arg1:lst
           arg2 lst

Function: Tests whether all the elements of arg1 are contained in arg2

Returns: Returns t if all elements of arg1 are contained in arg2 else
nil.


Symbol operations
-----------------

Testing whether a symbol has a value
------------------------------------
boundp

Syntax:   (boundp <symbol>)
Type:     subr, symbol op
Argument: <symbol>:<sym>

Returns: t if the argument <symbol> is bound to a value in the current
         environment, else nil.


Example:
(setq A '(a b c))
(boundp 'A)   ;=> t
(clear A)     ;=> t                   ; clear the symbol A
(boundp 'A)   ;=> nil


Creating a Symbol from a string
-------------------------------
intern

Syntax:    (intern <string>)
Type:      subr,symbol op
Argument:  <string>:chr a character vector containing a valid symbol
           name.

Function: If a symbol with a name equal to <string> does not already
           exist, a new symbol is created from the argument.

Returns:   The symbol with name equal to <string>.

Example:
(intern "Fred") ;=> Fred


Generating Symbols
------------------
gensym

Syntax: (gensym)
Type:   subr,symbol op
Implicit argument: #GS:<chr>

Where: #GS is bound to a character vector of which the first element
       must be an upper or lower case alphabetic character (A-Z,a-z),
       and remaining elements (if any) digits (0-9).

Function: Creates a symbol from the character vector bound to
           #GS. This is equivalent to performing the operation:

 	    (intern #GS)

           Then a new character vector is created from the original
	   character vector by incrementing the rightmost digit /
	   alphabetic character and carrying any overflow to the
	   left. If the character on the right would not wrap the new
	   vector is bound to #GS. It's default value at system
	   startup is "G0000000".

Returns: The symbol made from the current value of #GS


Note: (gensym) will fail when the value of #GS cannot be incremented. 
      i.e. when it starts with a "z" and all the remaining characters (if
      any) are "9"'s. 
      
Example:
(setq #GS "z0") ;=> "z0"
(FOR I 1 9 (print (list (gensym) #GS)))
(z0 "z1")
(z1 "z2")
(z2 "z3")
(z3 "z4")
(z4 "z5")
(z5 "z6")
(z6 "z7")
(z7 "z8")
(z8 "z9")
; return value of FOR => 10
(gensym)
;=> gensym Improper function argument: #GS would wrap
#GS  ;=> "z9"

Property lists
--------------

Discussion

Each symbol has a unique global property list that can be used to
store information relating to the symbol. A property list is a list
of (<property> <value>) pairs. There are three functions for manipulating
property lists on a symbol:

put: adds or modifies a property
get: retrieves a property
remprop: removes a property

Note that these functions are all subr's, i.e. they evaluate all their
arguments.

Addinng or modifying a property
-------------------------------
put

Syntax: (put <symbol> <property> <value>)
Type: subr,symbol op

Function: If the <property> does not exist on the property list of
           <symbol> the <property> with its associated value is added
           to the <symbol>'s property list, otherwise the previous value
           associated with the property is replaced with <value>.

Returns:  <value>

Examples:

(put 'Fred 'Age 39)                    ;=> 39
(put 'Fred 'Height 1.79)               ;=> 1.79
(put 'Fred 'Consort 'Suzi)             ;=> Suzi
(put 'Fred 'Friends '(Tom Dick Harry)) ;=> (Tom Dick Harry)

Getting a symbol property
-------------------------
get

Syntax: (get <symbol> <property>)
Type: subr, symbol op

Function: Retrieves the value associated with <property> on
	   <symbol>. 

Returns: If the <property> is found on the <symbols>'s property list
	 the associated value is returned otherwise the function
	 returns nil.

Examples: Assume that examples above for (put) have been entered then

(get 'Fred 'Age)     => 39
(get 'Fred 'Weight)  => nil
(get 'Fred 'Height)  => 1.79
(get 'Fred 'Consort) => Suzi
(get 'Fred 'Friends) => (Tom Dick Harry)


Removing a property
-------------------
remprop

Syntax: (remprop <symbol> <property>)
Type: subr, symbol op

Function: Removes the the <property> from  <symbol>. 

Returns: t if successful otherwise returns nil.

Examples: Assume that examples for putp have been entered

(get 'Fred 'Consort)     ;=> Suzi
(remprop 'Fred 'Consort) ;=> t
(get 'Fred 'Consort)     ;=> nil

Arithmetic
----------

These functions are convenience functions that complement the APL
arithmetic functions.

incr

sqr

sqrt


modexp

Syntax:    (modexp base arg mod)
Type:      subr, aplex
Arguments: base: numeric singleton
           arg: numeric array
	   mod: numeric singleton

Function: A slightly more accurate and efficient implementation of
          modular exponentiation.

Returns: numeric array with the same shape as arg where each element
         is the result of taking the xth power of base modulo mod,
         where x is the element of arg corresponding to the resulting
         element of the result. (modexp B E M) => (| M (exp B E))

Examples: #IO ;=> 0

(modexp 2 (i 19) 13)  ;=> [1 2 4 8 3 6 12 11 9 5 10 7 1 2 4 8 3 6 12 11]
(modexp 2 (i 19) 21)  ;=> [1 2 4 8 16 11 1 2 4 8 16 11 1 2 4 8 16 11 1 2]
(| 21 (exp 2 (i 19))) ;=> [1 2 4 8 16 11 1 2 4 8 16 11 1 2 4 8 16 11 1 2] 


Integer part of a number
------------------------

int
Syntax: (int <val>array:num)


Returns: An array of the same shape as val where each element is the
integer part of the corresponding element in val. If val is complex
the integer part of only the real part is returned.

This function differes from the APL floor function (f) which returns
the smallest integer less than or equal to the argument.

(f -1.4)   ;=> -2
(int -1.4) ;=> -1

Example: 
--------
    (int (/ (p [10 10] (- 50 (i 100))) 10)) ;=>
[ 5  4  4  4  4  4  4  4  4  4
  4  3  3  3  3  3  3  3  3  3
  3  2  2  2  2  2  2  2  2  2
  2  1  1  1  1  1  1  1  1  1
  1  0  0  0  0  0  0  0  0  0
  0 -0 -0 -0 -0 -0 -0 -0 -0 -0
 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
 -2 -2 -2 -2 -2 -2 -2 -2 -2 -2
 -3 -3 -3 -3 -3 -3 -3 -3 -3 -3
 -4 -4 -4 -4 -4 -4 -4 -4 -4 -4]

Fractional part of a number
---------------------------

frc
Syntax: (frc <val>array:num)

Returns: An array of the same shape as val where each element is the
fractional part of the corresponding element in val. If val is complex
the fractional part of only the real part is returned.


Example:
--------
    (frc (/ (p [10 10] (- 50 (i 100))) 10)) ;=>
[ .9  .8  .7  .6  .5  .4  .3  .2  .1  0
  .9  .8  .7  .6  .5  .4  .3  .2  .1  0
  .9  .8  .7  .6  .5  .4  .3  .2  .1  0
  .9  .8  .7  .6  .5  .4  .3  .2  .1  0
  .9  .8  .7  .6  .5  .4  .3  .2  .1  0
 -.1 -.2 -.3 -.4 -.5 -.6 -.7 -.8 -.9 -0
 -.1 -.2 -.3 -.4 -.5 -.6 -.7 -.8 -.9 -0
 -.1 -.2 -.3 -.4 -.5 -.6 -.7 -.8 -.9 -0
 -.1 -.2 -.3 -.4 -.5 -.6 -.7 -.8 -.9 -0
 -.1 -.2 -.3 -.4 -.5 -.6 -.7 -.8 -.9 -0]

Test for integer
----------------

intp

(intp (/ (p [10 10] (i 100)) 10))
[0 0 0 0 0 0 0 0 0 1
 0 0 0 0 0 0 0 0 0 1
 0 0 0 0 0 0 0 0 0 1
 0 0 0 0 0 0 0 0 0 1
 0 0 0 0 0 0 0 0 0 1
 0 0 0 0 0 0 0 0 0 1
 0 0 0 0 0 0 0 0 0 1
 0 0 0 0 0 0 0 0 0 1
 0 0 0 0 0 0 0 0 0 1
 0 0 0 0 0 0 0 0 0 1]
(see pyth.al)

APL Functions

The primitive polyadic functions

Arity>2 case

When the number of arguments exceeds 2 the dyadic function is applied
to the first two arguments and then succesively to the result of the
previous application and the next argument until it has been applied
to all arguments. For example:
(+ 1 2 3 4) => (+ (+ (+ 1 2) 3) 4) => 10
(- 1 2 3 4) => (- (- (- 1 2) 3) 4) => -8


Conformance of arguments
Shape of result: all args scalar -> scalar, any arg vect -> vect

(+ 1 2)    => 3
(+ 1 [2])  => [3]
(+ 1 [])   => []
(+ [1] []) => []
(+ 1 [1 2 3])   => [2 3 4] 
(+ [1] [1 2 3]) => [2 3 4]
(+ [1 2] [1 2 3]) => Error: + Domain / Range error: exec
(+ [1 2 3] [1 2 3]) =>[2 4 6]
(setq P (p [2 3 4] (i 24))) =>
[ 1  2  3  4
  5  6  7  8
  9 10 11 12
 
 13 14 15 16
 17 18 19 20
 21 22 23 24]

(setq Q (p [2 3 1] (i 6)))
[1
 2
 3
 
 4
 5
 6]

(* P Q) =>
[  1   2   3   4
  10  12  14  16
  27  30  33  36
 
  52  56  60  64
  85  90  95 100
 126 132 138 144]


Addition
--------
+

Syntax: (+ arg*) => <res>
Type: subr,scalar primitive
Arguments can be scalar and arrays.

Nilladic case: If no argument is given returns 0
Monadic case:  If given only one argument it returns a copy of the
	       argument.

Polyadic case:

Function: Returns the sum of all arguments.
All non-scalar arguments must have the same shape.
(p <res>) => [] for no or all scalar args
          => (p non-scalar-arg)


Subtraction
-----------
-

Syntax: (- arg*) => <res>
Arguments: arg:num scalar | array

Nilladic case: If no argument is given returns 0
Monadic case:  Returns the negative of the argument if given only one argument.

Polyadic case:

Funtion: Returns the the result of subtracting the sum of all arguments
         following the first argument from the first argument.
	 Arguments can be scalar and arrays.
All array arguments must have the same shape.
(p res) => [] for no or all scalar args
        => (p non-scalar-arg)

Euclidean Distance
------------------
dist


(dist arg1 arg2) ;=> (sqrt (+ (sqr arg1) (sqrarg2)))
(dist 3 4)                 ;=> 5
(dist [3 6] [4 8])         ;=> [5 10]
(dist [3 6] [4 8] [13 15]) ;=> [14 18]
(dist [5 10] [13 15])      ;=> [14 18]

Multiplication / Signum
-----------------------
Symbol: *

Monadic

Function:  Signum
Syntax:    (* arg) => <res>
Type:      subr,scalar-prim
Arguments: arg:numeric
           #CT 

Function: Each element in res is set to either 1, 0 or -1 depending
           on whether the corresponding element in arg is positive,
           zero or negative respectively.

Returns:   <res>
	   Where (eql (p    arg) (p    <res>)) => t
	   and   (eql (rank arg) (rank <res>)) => t

Division
--------
/

Exponentiation
--------------
Symbol: exp

Monadic

Function:  Natural exponent
Syntax:    (exp arg) => <res>
Type:      subr,prim
Arguments: arg:numeric

Function: Each element in <res> is set to the value of e raised to 
	   the power of the corresponding element in arg.

Returns:   <res>
	   Where (eql (p    arg) (p    <res>)) => t
	   and   (eql (rank arg) (rank <res>)) => t

Abs / Modulus
---------------- 
|

Monadic

Function:  Absolute value
Syntax:    (| arg) => <res>
Type:      subr,prim
Arguments: arg:numeric

Function: Each element in <res> is set to the absolute value of the
	   corresponding element in arg.

Returns:   <res>
	   Where (eql (p    arg) (p    <res>)) => t
	   and   (eql (rank arg) (rank <res>)) => t

Factorial / Binomial
--------------------
!



(de co (m n) (/ (! n) (* (! m) (! (- n m)))))



Trigonometric, Hyperbolic, Pythagorean and Complex Number functions
-------------------------------------------------------------------
%


Nilladic case
-------------

(%) => 0

Monadic case
------------
(% arg) => (* pi arg)


Dyadic cases
------------

Syntax: (% <op> arg)
Where: for real arg     -8 <= <op> <= 8 
       for complex arg -12 <= <op> <= 12 
The functions generated for the specific values of <op> are listed in
the tables below.


 Real argument

 Return: The shape of the result is the same as that of arg.
 	 If the op is -7 and there is an element of arg such that



-8 : (- (% 8 arg))
-7 : (atanh arg)
-6 : (acosh arg)
-5 : (asinh arg)
-4 : (sqrt (- (sqr arg) 1))
-3 : (atan arg)
-2 : (acos arg)
-1 : (asin arg)
 0 : (sqrt (- 1 (sqr arg)))
 1 : (sin arg)
 2 : (cos arg)
 3 : (tan arg)
 4 : (sqrt (+ 1 (sqr arg)))
 5 : (sinh arg)
 6 : (cosh arg)
 7 : (tanh arg)
 8 : (sqrt (- (+ 1 (sqr arg))))

Complex Argument

Return: The shape of the result is the same as that of arg.
	If there is an op such that -12 <= <op> <=8 the result will be
	complex otherwise it is real.
	
-12 : (expt (* arg 0j1))
-11 : (* arg 0j1)
-10 : (conjugate arg)
 -9 : arg
 -8 : (- (% 8 arg))
 -7 : (atanh arg)
 -6 : (acosh arg)
 -5 : (asinh arg)
 -4 : (sqrt (- (sqr arg) 1))
 -3 : (atan arg)
 -2 : (acos arg)
 -1 : (asin arg)
  0 : (sqrt (- 1 (sqr arg)))
  1 : (sin arg)
  2 : (cos arg)
  3 : (tan arg)
  4 : (sqrt (+ 1 (sqr arg)))
  5 : (sinh arg)
  6 : (cosh arg)
  7 : (tanh arg)
  8 : (sqrt (- (+ 1 (sqr arg)))) 
  9 : (real arg)
 10 : (* arg (conjugate arg)) same as (| arg)
 11 : (imag arg)
 12 : (phase arg) same as (atan (/ (imag arg) (real arg)))

Examples:

; splitting a complex vector into real and imaginary parts
(setq R (o '% [9 11] [2j4 1j3 1 0j6])) ;=>
 [2 1 1 0
  4 3 0 6]
(p R) => [2 4]
; Putting it back together again
(. '+ '%  [ -9 -11] R) ;=> [2j4 1j3 1 0j6]

; splitting a complex matrix into real and imaginary parts
(o '% [9 11] (p [3 4] [2j4 1j3 1 0j6])) =>
[2 1 1 0
 2 1 1 0
 2 1 1 0
 
 4 3 0 6
 4 3 0 6
 4 3 0 6]
(p #RS) => [2 3 4]

; Creating a vector with an angle of 30 degrees and a length of 10
(setq R (* 10 (% [2 1] (% (/ 30 180))))) ;=> [8.660254038 5]
(sqrt (r '+ (sqr R)))                    ;=> 10
(* 180 (/ (% -3 (r '/ (rev R))) (% 1)))  ;=> 30
; or less cryptically
(setq R (* 10 (% [2 1] (rad 30))))       ;=> [8.660254038 5]
(deg (atan (r '/ (rev R))))              ;=> 30
; (rad) (deg) and (atan) are defined in lisp/trig.al



Logarithm
---------
Symbol: l

Monadic

Function:  Natural logarithm
Syntax:    (l arg) => <res>
Type:      subr,prim
Arguments: arg:numeric

Function: Each element in <res> is set to the natural logarithm 
	   (log to the base e) of the corresponding element in arg.

Returns:   <res>
	   Where (eql (p    arg) (p    <res>)) => t
	   and   (eql (rank arg) (rank <res>)) => t

Floor / Minimum
---------------
Symbol: f

Monadic

Function:  Floor
Syntax:    (f arg) => <res>
Type:      subr,prim
Arguments: arg:numeric

Function: Each element in <res> is the greatest integer value smaller
           than or equal to the corresponding element in arg.

Returns:   <res>
	   Where (eql (p    arg) (p    <res>)) => t
	   and   (eql (rank arg) (rank <res>)) => t

See also: (int)

Ceil / Maximum
--------------
c

Monadic 

Function: Ceil
Syntax:   (c arg) => <res>
Type:      subr,prim
Arguments: arg:numeric

Function: Each element in res is the smallest integer value not less
           than the corresponding element in <num>.

Returns:   <res>
	   Where (eql (p    arg) (p    <res>)) => t
	   and   (eql (rank arg) (rank <res>)) => t

Logical and (lcm)
-----------------
APL logical operator
^

Nilladic case
(^) => 1

Monadic case not defined

Dyadic case
Syntax: (^ arg1 arg2) 

Function: If the arguments are booleans returns a the numeric result
          where each element is a 1 or 0 as a function of the truth
          table applied to the corresponding elements in arg1 and
          arg2 otherwise the lowest common multiple is returned.

Arguments: arg1:numeric, arg2:numeric
  	   arg1, arg2 can be scalar, vector or arrays

If one arg is scalar and the other not its shape will automatically be
extended to conform to the shape of the non scalar argument.
otherwise (= (p arg1) (p arg2)) => t
(= (p res)  (p argx)) => t where argx is the argument of greatest rank

Truth table:
(o '^ [0 1] [0 1]) ;=> [0 0
                       0 1]

Examples:
(^ 1 [1 0 0 1]) ;=> [1 0 0 1]

(^ [1 0 1 0] [1 0 0 1]) ;=> [1 0 0 0]

(^ 6 7) ;=> 42

Logical nand - not and
----------------------
APL logical operator
~^

Nilladic case
(~^) => 0

Monadic case not defined

Dyadic case
Syntax: (~^ arg1 arg2) 

Function: If the arguments are booleans returns a numeric result
          where each element is a 1 or 0 as a function of the truth
          table applied to the corresponding elements in arg1 and
          arg2 

Arguments: arg1:numeric, arg2:numeric
  	   arg1, arg2 can be scalar, vector or arrays

If one arg is scalar and the other not its shape will automatically be
extended to conform to the shape of the non scalar argument.
otherwise (= (p arg1) (p arg2)) => t
(= (p res)  (p argx)) => t where argx is the argument of greatest rank

Truth table:
(o '~^ [0 1] [0 1]) ;=> [1 1
                         1 0]

Examples:
(~^ 1 [1 0 0 1]) ;=> [0 1 1 0]

(~^ [1 0 1 0] [1 0 0 1]) ;=> [0 1 1 1]

Logical inclusive or (gcd)
--------------------------
v
APL logical operator

Nilladic case
(v) ;=> 0

Monadic case not defined

Dyadic case
Syntax: (v arg1 arg2)
Function: Returns arg1 v arg2 
(nump arg1) => t
(nump arg2) => t
arg1, arg2 can be scalar, vector or arrays
If one arg is scalar and the other not its shape will automatically be
extended to conform to the shape of the non scalar argument.
otherwise (= (p arg1) (p arg2)) => t
(= (p res)  (p argx)) => t where argx is the argument of greatest rank


Truth table for boolean arguments:
(o 'v [0 1] [0 1]) => [0 1
                       1 1]

If the arguments are not boolean i.e. 1 or 0 then the greatest common
divisor is returned.

Examples:
---------
(v [0 0 1 1] [0 1 0 1]) ;=> [0 1 1 1]

(v 714 294) ;=> 42

Logical inclusive nor - not or
------------------------------
~v
APL logical operator

Nilladic case
(~v) ;=> 1

Monadic case not defined

Dyadic case
Syntax: (v arg1 arg2)
Function: Returns arg1 v arg2 
(nump arg1) => t
(nump arg2) => t
arg1, arg2 can be scalar, vector or arrays
If one arg is scalar and the other not its shape will automatically be
extended to conform to the shape of the non scalar argument.
otherwise (= (p arg1) (p arg2)) => t
(= (p res)  (p argx)) => t where argx is the argument of greatest rank

Truth table for boolean arguments:
(o '~v [0 1] [0 1]) => [1 0
                        0 0]


Examples:
---------
(~v [0 0 1 1] [0 1 0 1]) ;=> [1 0 0 0]


Logical exclusive or
--------------------
APL logical operator
x

Nilladic case
(x) => 0

Monadic case not defined

Dyadic case
(x arg1 arg2) => arg1 x arg2 
(nump arg1) => t
(nump arg2) => t
arg1, arg2 can be scalar, vector or arrays
If one arg is scalar and the other not its shape will automatically be
extended to conform to the shape of the non scalar argument.
(= (p arg1) (p arg2)) => t
(= (p res)  (p arg1)) => t

Truth table:
(o 'x [0 1] [0 1]) => [0 1
                       1 0]
APL Primitive Relational Functions
----------------------------------
Discussion

The dyadic < , <= , =, <>, >=, and >: functions are commonly called
relational functions. The domain of relational functions is not
restricted; they can take both numeric and character
arguments. However, only the equal and not equal functions can have
mismatched arguments, that is, one numeric and one character argument
simultaneously.


Less Than
---------
APL predicate
<

Nilladic case
(<) => 0

Monadic case
(< arg) => (< arg 0) 
(< [-1 0 1]) => [1 0 0]

Dyadic case
(o '< [-1 0 1] [-1 0 1]) =>
[0 1 1
 0 0 1
 0 0 0]


Less Than or Equal
------------------
APL predicate
<=

Nilladic case
(<=) => 1

Monadic case
(<= arg) => (<= arg 0) 
(<= [-1 0 1]) => [1 1 0]

Dyadic case
(o '<= [-1 0 1] [-1 0 1]) =>
[1 1 1
 0 1 1
 0 0 1]

Equal
-----
APL predicate
=

Nilladic case
(=) => 1

Monadic case
(nump arg) => t
(= arg) => (= arg 0) 
(= [-1 0 1]) =>[0 1 0]

Dyadic case
(o '= [-1 0 1] [-1 0 1]) =>
[1 0 0
 0 1 0
 0 0 1]

(= "hello" 'hello) => [1 1 1 1 1]

(= $[1 2 3j1 "hello" 'c [4 5 6]] $[1 2 3j1 "hello" 'c [4 5 6]]) => [1 1 1 1 1 1]
      
(de =eq (x y)
(implod (mapcar '(lambda (x y) (if (eq x y) 1 0)) (explod x) (explod y)))) =>
=eq

(=eq $[1 2 3j1 "hello" c [4 5 6]] $[1 2 3j1 "hello" c [4 5 6]]) =>
[1 1 1 0 1 0]

Greater Than or Equal
---------------------
APL predicate
>=

Nilladic case
(>=) => 1

Monadic case
(>= arg) => (>= arg 0) 
(>= [-1 0 1]) => [0 1 1]

Dyadic case
(> arg1 arg2) => arg1 > arg2 
(nump arg1) => t
(nump arg2) => t

Truth table:
(o '>= [-1 0 1] [-1 0 1]) => 
[1 0 0
 1 1 0
 1 1 1]

Greater Than
------------
APL predicate 
>

Nilladic case
(>) => 0

Monadic case
(> arg) => (> arg 0)
(> [-1 0 1]) => [0 0 1]

Dyadic case
(> arg1 arg2) => arg1 > arg2 
(nump arg1) => t
(nump arg2) => t

Truth table:
(o '> [-1 0 1] [-1 0 1]) =>
[0 0 0
 1 0 0
 1 1 0]


Discussion
----------
Truth tables for the APL logical connectives

The list of 10 APL logical connectives in L2 is complete since truth
tables with all zeros or ones or rows of all ones and all zeros or
columns of all ones and all zeros are not valid truth tables.

Xor (x) is equivalent to not equal (<>) for boolean arguments

(de TT (F) (o F [0 1] [0 1])) ;; truth table for F
(a L2 '(^ > < <> v ~v = >= <= ~^))

(mapcar '(lambda (X) (TT X)) L2) ;; Valid truth tables
=>
([0 0
 0 1]
 [0 0
 1 0]
 [0 1
 0 0]
 [0 1
 1 0]
 [0 1
 1 1]
 [1 0
 0 0]
 [1 0
 0 1]
 [1 0
 1 1]
 [1 1
 0 1]
 [1 1
 1 0]
)

(let ((#IO 0))	
     (mapcar '(lambda (X) (p [2 2] (enc (p 4 2) X)))
     	(SCOMP (explod (i 16))
		       (mapcar '(lambda (X) (dec 2 (rav (TT X))))
		              L2)))) ;; invalid truth tables
=>			      
([0 0
 0 0]
 [0 0
 1 1]
 [0 1
 0 1]
 [1 0
 1 0]
 [1 1
 0 0]
 [1 1
 1 1]
)

;; (SCOMP A B) is a set complement function that returns elements in A
;; that are not in B
;;  SCOMP =>
;; (lambda (A B) (remove-if '(lambda (X) (member X B)) A))
;; remove-if =>
;; (lambda (F L) (mapcan '(lambda (X) (unless (F X) (list X))) L))



Index Generator
---------------
i

Syntax:   (i arg) => res
Type:     subr, mixed monadic
Argument: arg:num:scalar or vector


Returns a numeric vector
Scalar arg        (p arg) => []
Singleton vector  (p arg) => 1

   (eq arg (p res)) => t
   Case #IO => 0 (index origin set to zero)
     (i arg) => [0 1 2 ... (- arg 1)]
   Case #IO => 1 (index origin set to one)
     (i arg) => [1 2 3 ... arg]
   Case arg < #IO
     (i arg) => []

Two element vector (p arg) => [2]

Case (le (aref arg 1) (aref arg 2)) => t
(i arg) => {(aref arg 1) (+ (aref arg 1) 1) ...  (aref arg 2)}

Case (gt (aref arg 1) (aref arg 2)) => t
{(aref arg 1) (- (aref arg 1) 1) ...  (aref arg 2)}
 
Examples:
(a #IO 0)     ; Index origin 0   
(i 10)        ;=> [0  1  2  3  4  5  6  7  8  9]
(i [10])      ;=> [0  1  2  3  4  5  6  7  8  9]

(a #IO 1)     ; Index origin 1   
(i 10)        ;=> [1  2  3  4  5  6  7  8  9  10]
(i [10])      ;=> [1  2  3  4  5  6  7  8  9  10]

; Independent of index origin
(i [0 10])    ;=> [0  1  2  3  4  5  6  7  8  9  10]
(i [0 2 10])  ;=> [0  2  4  6  8  10]
(i [10  0])   ;=> [10  9  8  7  6  5  4  3  2  1  0]
(i [10 -2 0]) ;=> [10  8  6  4  2  0]

Index of
--------
ind

Syntax:    (ind arg1 arg2) => res
Type:      subr, type mixed dyadic
Arguments: arg1:ncr:array
           arg2:ncr:array
	   #CT,#IO implicit arguments
	   
Function: The result is the index of arg2 in arg1. For each element x
          in arg2, the corresponding element in res is the smallest
          index I such that (= (aref (rav arg1) I) x) => 1. If there
          is no I such that (= (aref (rav arg1) I) x) => 1 then the
          corresponding element in res is set to
	  (+ 1 (r 'c (i (p arg1)))).
	  If arg1 is the null vector [] then res has the value of the
          current #IO.

Return:   A numeric vector res whose shape is the same as that of
          arg2, that is (eq (p arg2) (p res)) => t 

Examples:

(setq #IO 1)    ;=> 1
(ind (i 10) 5)  ;=> 5
(ind (i 10) 22) ;=> 11
(ind [] 22)     ;=> 1
(ind "hello polly" "hellas") ;=> [1 2 3 3 12 12]

(setq #IO 0)    ;=> 0
(ind (i 10) 5)  ;=> 5
(ind (i 10) 22) ;=> 10
(ind [] 22)     ;=> 0
(ind "hello polly" "hellas") ;=> [0 1 2 2 11 11]
(ind [4 5] (p [2 3 4] (i 24))) ;=>
[2 2 2 2
 0 1 2 2
 2 2 2 2
 
 2 2 2 2
 2 2 2 2
 2 2 2 2]

Membership
----------
elt

Syntax:    (elt <elts> <set>)
Arguments: <elts> singleton or array of any type
           <set>  singleton or array of any type
Function: For each element in <elts> if it is contained in <sets> 1
           is placed in the result else 0 is placed.
Returns: Boolean vector

for (elt E S) => R
    (p R)    <=> (p E)
    (rank R) <=> (rank E)
    R <=> (r 'v (o '= E S))
    
Examples:

(elt 13 [2 3 5 7 11 13 17 19]) ;=> 1
(elt 14 [2 3 5 7 11 13 17 19]) ;=> 0
(elt [1 2 9] (i 5))  ;=> [1 1 0]
(elt [1 2 3] 1)      ;=> [1 0 0]
(elt "abc" 'a)       ;=> [1 0 0]
(elt $[a b c] $[a])  ;=> [1 0 0]
(elt $[a b c] 'a)    ;=> [1 0 0]
(elt $[nil b c] nil) ;=> [1 0 0]

Shape Reshape
-------------
p

Monadic case: shape

Syntax: (p arg)
Type: subr, Mixed
Argument: arg must be a singleton or array of any type.
Function: returns a vector of the shape of the argument.

Examples:

(p (i 10))  ;=> 10
(p (o '< (i 4) (i 5))) ;=> [4 5]
(p 1)       ;=> []
(p 'a)      ;=> [1]
(p 'lambda) ;=> [6]
(p ())      ;=> [3]                        ; equivalent to (p nil) or (p 'nil)
(p "a")     ;=> [1]
(p "Hello") ;=> [5]
(p [])      ;=> [0]                        ; Null vector
(p "")      ;=> [0]                        ; Null string
(p $[])     ;=> [0]                        ; Null reference vector


Dyadic case: reshape

(p vector arg) => res

(eq (p res) vector) => t

Reshapes arg to have dimensions vector. arg is truncated or replicated as
needed to fill the shape of vector.

Example:

(p [5 5] [1 0 0 0 0 0]) =>
[1 0 0 0 0
 0 1 0 0 0
 0 0 1 0 0
 0 0 0 1 0
 0 0 0 0 1]

(a X (p [0 3 4 5] 0))
X => []
; Note: lisp predicates treat all null vectors as equal regardless of shape
(eq X [])  ;=> t
; APL predicates do not:
(= X [])   ;=> Domain / Range error
(= X X)    ;=> t
(p (= X X)) ;=> [0 3 4 5]
(p [] 3) => 3
(p [] [3]) => 3
(p [] (p [2 3 4] (i 24))) ;=> 1
(p [] "abc")
;=> Improper function argument: cannot make dimensionless chr or ref
(p [] $[1 "asdasd" [2 3 4]])
;=> Improper function argument: cannot make dimensionless chr or ref
(p 10 nil)    ;=> "nilnilniln"
(p 10 $[nil]) ;=> $[nil nil nil nil nil nil nil nil nil nil]
(p 5 '(a b c))
;=> Improper function argument: argument 2 not Numeric or Character or
Reference
(p 5 $[(a b c)])   ;=> $[(a b c) (a b c) (a b c) (a b c) (a b c)]

Rank
----
rank

Syntax: (rank arg)
Type: subr, Mixed
Argument: arg is a scalar or an array of any type
Function: returns the number of dimenstions of arg as a scalar
          It is equivalent to (p(p arg)).

Examples:
(rank (p [2 3 4] (i 24))) => 3
(rank 1)                  => 0
(rank [])                 => 1

Tally
-----
tally

Syntax: (tally arg1)
Type:   subr
Argument: arg1:array
Function: returns the length of the first dimension as a scalar.

Examples:
(tally (p [2 3 4] (i 24))) => 2
(tally (i 24))             => 24
(tally 1)                  => 1
(tally [])                 => 0


Ravel
-----
rav

Syntax: (rav arg)
Type:   subr, Mixed

Returns: Vector of all elements of arg in row-major order.

Catenate
--------
cat

Syntax: (cat [<axis>] arg1 arg2)
Type:   subr, Mixed
Arguments: <axis>:num singleton
           arg1:ncr array
	   arg1:ncr array
	   The types of arg1 and arg2 must be the same.
Examples:

(setq A (p [3 3] "ABCDEFGHIJ")) =>
"ABC
 DEF
 GHI"

(setq C "*") => "*"

(cat A C) =>
"ABC*
 DEF*
 GHI*"

(cat C #RS) ;=>   ;; #RS is the result of the previous evaluation
"*ABC*
 *DEF*
 *GHI*"

(cat 1 C #RS) =>          ; Along first axis
"*****
 *ABC*
 *DEF*
 *GHI*"

(cat 1 #RS C) =>          ; Along first axis
"*****
 *ABC*
 *DEF*
 *GHI*
 *****"

(defun BOX (A C) (cat 1 (cat 1 C (cat C (cat A C))) C)) ;=> BOX

(BOX A "#") =>
"#####
 #ABC#
 #DEF#
 #GHI#
 #####"

;; Catenating a vector to a matrix
(cat  (p [7 9] "-")  "1234567")  ;=>
"---------1
 ---------2
 ---------3
 ---------4
 ---------5
 ---------6
 ---------7"

(princl (rav (cat  (p [7 9] "-")  "1234567")))  ;=> t
---------1---------2---------3---------4---------5---------6---------7

;; When the axis argument is not an integer the other arguments are
;;  "laminated" along a new dimension at (c <axis>)
(setq A (p [3 4] (i 12))) ;=>
[1  2  3  4
 5  6  7  8
 9 10 11 12]

(cat .5 A A) ;=>   ; duplicate plane in a new dimension
[1  2  3  4
 5  6  7  8
 9 10 11 12
 
 1  2  3  4
 5  6  7  8
 9 10 11 12]
(p (cat .5 A A)) ;=> [2 3 4]

(cat 1.5 A A) ;=>   ; duplicate rows in a new dimension
[1  2  3  4
 1  2  3  4
 
 5  6  7  8
 5  6  7  8
 
 9 10 11 12
 9 10 11 12]
(p (cat 1.5 A A)) ;=> [3 2 4]

(cat 2.5 A A)     ; duplicate columns in a new dimesion
[ 1  1
  2  2
  3  3
  4  4
 
  5  5
  6  6
  7  7
  8  8
 
  9  9
 10 10
 11 11
 12 12]

(p (cat 2.5 A A)) ;=> [3 4 2]

Deal
----
?

Monadic case:
Syntax: (? arg1) => res
Type: subr, scalar primitive
Arguments: arg1:num:any

arg1 is numeric scalar, vector or array
(eq (p res) (p arg1)) => t

Case arg1 >= 1:
If arg1 is scalar then res is a random number chosen from the
sequence (i arg1). Otherwise the jth element of res is a a random
number chosen from the sequence (i (aref arg1 j)).

Case arg1 = 0:
The elements of res are random values between 0 and 1 irrespective of #IO

Dyadic case:

Syntax: (? arg1 arg2) => res
Type: subr, scalar primitive
Arguments: arg1:num:scalar
           arg2:num:scalar
	   
arg1 and arg2 are numeric scalars
(eq (p res) arg1) => t
(le arg1 arg2) => t
Function: The arg1 elements of res are chosen from the range
	   #IO to (- arg2 (= #IO 0)) without repetition

Examples:
alps: #IO
1
(? 10) ;=> 5
(? (p 5 10)) ;=> [2 5 5 6 2]
(? (p [2 5] 10)) => [9 4 8 10 9
                     8 9 3  4 6]	 

alps: (? 10 10)
[6 2 5 9 7 3 8 1 4 10]
alps: (? 10 11)
[8 6 1 5 3 10 2 7 9 11]
alps: (setq #IO 0)
alps: (? 10 10)
[6 1 8 0 4 3 5 2 9 7]
alps: (aref ALPHA (? 6 (p ALPHA))) ; random 6 letter word
"esfpwi"


Reduce
------
r

Syntax: (r <op> [<axis> [<window>]] <array>)
Where: <op> is a primitive dyadic function used for the reduction
       <array> is the argument upon which the reduction is to be
               applied
       <axis> an optional argument to indicate along which dimension of
              <array> the reduction is to be performed. By default it
	      is the last axis. (see axis argument).
	      
       <window> an optional argument to specify the length and
                direction of the reduction. If (onep (| <window>)) the
                reduction is taken over the whole length of the axis.
                If <window> is positive the function is applied from
                left to right which is the default behaviour. If
		window is negative the function is applied from right to
                left as in standard APL.
       
       
Function:

Examples:
(r '+ [1 2 3 4])                 ;=> 10               ; Addition
(eval (I2P '(1 + 2 + 3 + 4)))    ;=> 10
(r '- [1 2 3 4])                 ;=> -8               ; Subtraction
(eval (I2P '(1 - 2 - 3 - 4)))    ;=> -8
(r '* [1 2 3 4])                 ;=> 24               ; Multiplication
(eval (I2P '(1 * 2 * 3 * 4)))    ;=> 24
(r '/ [1 2 3 4])                 ;=> 4.166666667e-2   ; Division
(eval (I2P '(1 / 2 / 3 / 4)))    ;=> 4.166666667e-2
(r '< [1 2 3 4])                 ;=> 1                ; less than
(eval (I2P '(1 < 2 < 3 < 4)))    ;=> 1
(r '<= [1 2 3 4])                ;=> 1                ; less than or equal
(eval (I2P '(1 <= 2 <= 3 <= 4))) ;=> 1
(r '= [1 2 3 4])                 ;=> 0
(eval (I2P '(1 == 2 == 3 == 4))) ;=> 0
(r '<> [1 2 3 4])                ;=> 1
(eval (I2P '(1 != 2 != 3 != 4))) ;=> 1
(r '>= [1 2 3 4])                ;=> 0
(eval (I2P '(1 >= 2 >= 3 >= 4))) ;=> 0
(r '> [1 2 3 4])              ;=> 0
(eval (I2P '(1 > 2 > 3 > 4))) ;=> 0


In APL\360 the reduction happens right to left. In order to be more in
line with lisp's occidental lexicographical order alps applies the
operators left to right. This is not an issue with commutative
functions. However, with non-commutative functions the default alps
invocation of the reduction operator will not behave in the same way
in as in APL/360.

For example with a reduction using the less than operator <:
  APL/360: </1 2 3 4    => 0 since 3<4 => 1<2 => 1<1 => 0
  alps: (r'< [1 2 3 4]) => 1 since 1<2 => 1<3 => 1<4 => 1

In order to address this issue alps also provides for right to left
semantics with the negative window argument for reduce:
(r '< 1 -1 [1 2 3 4]) ;=> 0

For non commutative operations the results differ:
(r '- 1 -1 [1 2 3 4 5])           ;=> 3
(r '- [1 2 3 4 5])                ;=> -13
(eval (I2P '(1 - 2 - 3 - 4 - 5))) ;=> -13

for commutative operations the results are the same:
(r '* [1 2 3 4 5])                 ;=> 120
(r '* 1 -1 [1 2 3 4 5])            ;=> 120
(eval (I2P '(1 * 2 * 3 * 4 * 5)))  ;=> 120
(! 5)                              ;=> 120

   
(a R (p [4 3] (i 12)))
(r '+ 1 4 R) ;=> [22 26 30]
(r '+ 1 2 R); => [ 5  7  9
                  11 13 15
                  17 19 21] 
(r '+ 2 2 R) ;=> [ 3  5
                   9 11
	  	  15 17
		  21 23]
		  
(r '- 1 2 (sqr (i 5)))                        ;=> [-3 -5 -7 -9]
(mapcar '(lambda (X) (eval (I2P  X)))
	'((1 - 4) (4 - 9) (9 - 16) (16 - 25))) ;=> (-3 -5 -7 -9)
	
;; a negative window reverses the arguments for the reduction function
(r '- 1 -2 (sqr (i 10)))                       ;=> [3 5 7 9]
(mapcar '(lambda (X) (eval (I2P  X)))
	'((4 - 1) (9 - 4) (16 - 9) (25 - 16))) ;=> (3 5 7 9)

This function is useful for calculating the set of first differences
of a vector:
(int (r '- 1 -2 (exp (i 9))))  ;=> [4 12 34 93 255 693 1884 5122]
It is also useful for smoothing data by taking a moving average over
the vector:

(/ (r '+ 1 12 V) 12) ; e.g. moving 12 month average

zero length window:
if (r op axis 0 arg) => R
then (p R) => (+ (p arg) (= axis (i (rank arg))))
(r '* 1 0 (p [2 3] 0)) ;=>
[1 1 1
 1 1 1
 1 1 1]
 
(p (r '* 1 0 (p [2 3] 0))) ;=> [3 3]

(r '* 1 0 (p [2 3] (i 12))) ;=>
[1 1 1
 1 1 1
 1 1 1]
(p (r '* 1 0 (p [2 3] (i 12)))) ;=> [3 3]

reduction along null dimension
(r '/ 2 (p [2 0 3] 0)) ;=>
[1 1 1
 1 1 1]

Scan
----
s

Syntax: (s <op> [<axis> [<order>]] <array>)
Where: <op> is a primitive dyadic function used for the reduction
       <array> is the argument upon which the reduction is to be
               applied
       <axis> an optional argument to indicate along which dimension of
              <array> the reduction is to be performed. By default it
	      is the last axis. (see axis argument).
	      
       <order> an optional argument to specify the order of applying
               <op> on the scan. If <order> is positive the
               <op> is applied left to right which is the
               default behaviour. If <order> is negative the
               <op> is applied right to left as in standard APL.
       
Examples:
(s '+ (i 10)) ;=> [1 3 6 10 15 21 28 36 45 55] running sum

(setq M (p [4 5] (i 20))) =>
[ 1  2  3  4  5
  6  7  8  9 10
 11 12 13 14 15
 16 17 18 19 20]

(s  '+ 1 M (i 20)) ;=> running sum down columns)
[ 1  2  3  4  5
  7  9 11 13 15
 18 21 24 27 30
 34 38 42 46 50]

(s  '+ 2 (p [4 5] (i 20)) ;=> running sum across rows)
[ 1  3  6 10 15
  6 13 21 30 40
 11 23 36 50 65
 16 33 51 70 90]

(s '- [1 2 3 4 5]) ;=>  [1 -1 -4 -8 -13]
;; The result is calculated thus
{1 (- 1 2) (-(- 1 2) 3) (-(-(- 1 2) 3) 4) (-(-(-(- 1 2) 3) 4) 5)} ;=>
[1      -1          -4                -8                    -13]

;; reversing the order of applcation as in APL
(s '- -1 -1 [1 2 3 4 5]) ;=>     [1 -1 2 -2 3]
;; The result is calculated thus
{1 (- 1 2) (- 1(- 2 3))  (- 1(- 2(- 3 4))) (- 1(- 2(- 3(- 4 5))))} ;=>
[1     -1           2                -2                     3]
;; scan using negative order is equivalent to an alternating sum where
;; the order is the same as positive order with flipping of alternate
;; minus signs.
{1 (- 1 2) (+(- 1 2) 3) (-(+(- 1 2) 3) 4) (+ (-(+(- 1 2) 3) 4) 5)} ;=> 
[1     -1            2                  -2                          3]
;; in infix notation it would look like:
[1 (1 - 2) (1 - 2 + 3) (1 - 2 + 3 - 4) (1 - 2 + 3 - 4 + 5)]
[1     -1           2              -2                   3]

The following expression leaves the leftmost 1 turned on:
(s '< 1 -1 [0 0 1 1 0 1 1 0]) ;=> [0 0 1 0 0 0 0 0]
Note in APL this is simply <\0 0 1 1 0 1 1 0 => 0 0 1 0 0 0 0 0
In alps we use the -1 <order> parameter after the axis to select
APL semantics when the operation is non-commutative


(aref " o" (+ #IO (FoFM '(lambda (X) (s '<> X)) (p 32 1) 31)))

Outer Product
-------------
o

Syntax
(o <op> arg1 arg2)

Computes the outer or cross product of arg1 and arg2 with respect to
the primitive dyadic function <op>. arg1 and arg2 must be of the
same type. The shape of the result is the concatenation of the shapes
of arg1 and arg2 respectively.

Example:
; set output to 12 signficant digits and default Field width
alps: (a #SD 12 #FW 0)
; Compute the outer productwrt exponentiation of (i 10) and (i 10)
(o 'exp (i 10) (i 10)) =>
[ 1   1    1     1      1       1        1         1          1           1
  2   4    8    16     32      64      128       256        512        1024
  3   9   27    81    243     729     2187      6561      19683       59049
  4  16   64   256   1024    4096    16384     65536     262144     1048576
  5  25  125   625   3125   15625    78125    390625    1953125     9765625
  6  36  216  1296   7776   46656   279936   1679616   10077696    60466176
  7  49  343  2401  16807  117649   823543   5764801   40353607   282475249
  8  64  512  4096  32768  262144  2097152  16777216  134217728  1073741824
  9  81  729  6561  59049  531441  4782969  43046721  387420489  3486784401
 10 100 1000 10000 100000 1000000 10000000 100000000 1000000000 10000000000]

; Compute the outer product wrt <  of (i 10) and (i 10)produces an
; upper triangular matrix with the diagonal elements equal to zero.

(o '< (i 10) (i 10)) ;=>
[0 1 1 1 1 1 1 1 1 1
 0 0 1 1 1 1 1 1 1 1
 0 0 0 1 1 1 1 1 1 1
 0 0 0 0 1 1 1 1 1 1
 0 0 0 0 0 1 1 1 1 1
 0 0 0 0 0 0 1 1 1 1
 0 0 0 0 0 0 0 1 1 1
 0 0 0 0 0 0 0 0 1 1
 0 0 0 0 0 0 0 0 0 1
 0 0 0 0 0 0 0 0 0 0]

Inner Product
-------------
.

Syntax: (. <Op1> <Op2> <Array1> <Array2>)
Type:   subr,
Arguments: <Op1>:and Op2 are dyadic primitive functions. The last
	   dimension of <Array1> must be equal to the first dimension
	   of <Array2>.
	   I.e. (eq (tk -1 (p <Array1>)) (tk 1 (p <Array2>))) => t
           Scalar arguments for <Array1> and <Array2> are automatically
           extended to conform to the other argument.

Operation: <Op1> is applied to each element along the last dimension
           of <Array1> with each element along the first dimension of
           <Array2>. The result of each application is reduced with
           <Op2> the reduction occurring from right to left.
	   
Returns: The shape of the result of the operation is the vector
         comprised of catenation of the shape of Array1 without the
         last dimension and the shape of <Array2> without its first
         dimension.
	 (p <result>) => (cat (dp -1 (p <Array1>)) (dp 1 (p <Array2>)))

Example:
; Matrix multiplication
(setq P (tr (p [2 10] (i 10)))) ;=>
[ 1  1
  2  2
  3  3
  4  4
  5  5
  6  6
  7  7
  8  8
  9  9
 10 10]

(p P)      ;=> [10 2]
(p [10 1]) ;=> [2] 
; NB the last dimension of P equals the first dimension of [10 1]

(. '+ '* P [10 1]) ;=> [11 22 33 44 55 66 77 88 99 110]
(. '+ '* P [11 1]) ;=> [12 24 36 48 60 72 84 96 108 120]
(. '+ '* P [11 2]) ;=> [13 26 39 52 65 78 91 104 117 130]
(. '+ '* [11 2] (tr P)) ;=> [13 26 39 52 65 78 91 104 117 130]
;Scalar extension
(. '+ '* 10 (i 10))      ;=> 550
(. '+ '* 10 (tr (i 10))) ;=> [550]
(. '+ '* (i 10) 10)      ;=> 550
(. '+ '* (tr (i 10)) 10) ;=> [10 20 30 40 50 60 70 80 90 100]
(. '+ '* 10 2)           ;=> 20

Compress
--------
k

Syntax:  (k [<axis>:ns] <selector>:nsv <array>:ncra)

<axis> The axis in <array> along which the compression is to be
       effected.  If axis is not specified the compression takes place
       along the last dimension i.e.  <axis> <=> (rank <array>)
       
<selector> is a numeric vector with zeros in the position of the
           corresponding elements along <axis> in <array> to be
           compressed. Positive elements in the vector indicate that
           the corresponding element along <axis> in <array> is to be
           replicated. Negative elements indicate that the fill
           elements 0, "" or nil are to be replicated and inserted at
           the corresponding position. The number of non-negative
           elements in the selector must equal the number of elements
           along the axis of compression. A positive singleton
           selector will be extended to match the <axis> of <array>

<array> An array of any type. If <array> is a singleton it is extended
	to match the number of non-negative elements in <selector>

Dimensions and Ranks:
for (k A B K) => R
(r '+ (>= A)) <=> (aref (p B) K)
(p R) <=> {(tk (- K 1) ( p B)) (r '+ (| A)) (dp K (p B))}
(rank R) <=> (rank B)

Examples:
(k [1 0 1 0 1 0 0 0 0 ] (i 9)) ;=> [1 3 5]

(k [1 0 1 0 1 0 0 0 0 ] "abcdefghi") ;=> "ace"

(k 1 [0 1] (p [2 3] "YESNO "))  ;=> "NO " ; using axis argument
(k 1 [1 0] (p [2 3] "YESNO "))  ;=> "YES"

(k [1 1 0 0 1 0] $[begin 1 dead doornail 2 end]) => $[begin 1 2] 

(k 3 4) ;=> [4 4 4]

(k 3 [1 2 3]) ;=> [1 1 1 2 2 2 3 3 3]  ; extension of singleton selector

(k [1 2 3] 4) ;=> [4 4 4 4 4 4]        ; extension of singleton array

(k [-1 2 -3] 5) ;=> [0 5 5 0 0 0])

(k [1 3 1  0 -4  2 -3]
   [5 7 9 11    13   ])  ;=>  [5 7 7 7 9 0 0 0 0 13 13 0 0 0])
(setq A (p [2 3] (i 6)))
[1 2 3
 4 5 6]

(k 2 A) ;=>  duplicate columns
[1 1 2 2 3 3
 4 4 5 5 6 6]

(k 1 2 A) ;=>  duplicate rows
[1 2 3
 1 2 3
 4 5 6
 4 5 6]

Expand
------
ex

Syntax: (ex [<axis>] <selector> <array>)

<selector> is a boolean vector with zeros in the position of the
corresponding elements along <axis> in <array> to be expanded. The
number of non-zero elements in the selector must equal the number of
elements along the axis of expansion. If axis is not specified the
expansion takes place along the last dimension i.e. (= <axis> (p
<array>)) => 1

<array> is expanded along <axis> by inserting the fill elements 0, ""
or nil in the positions corresponding to the zero elements in the
<selector>.

Examples
--------

;;; Numeric
(ex [1 0  1 0 0 1 0 0 0 ] [1 2 3]) => [1 0 2 0 0 3 0 0 0]
;;; Character
(ex  [1 0 1 0 0 1 0 0 0 ] "ace")   => "a c  e   "
;;; Symbol
(ex [1 0 1 0 1] 'ace)              => "a c e"
;;; Reference vector
(ex [0 1 0 1 0] $[begin end])       => $[nil begin nil end nil]

(setq A (p [3 4] (i 12))) ;=>
[1  2  3  4
 5  6  7  8
 9 10 11 12]

(ex [1 0 1 0 1 0 1] A) ;=> by default expansion is along the last dimension
[1 0  2 0  3 0  4
 5 0  6 0  7 0  8
 9 0 10 0 11 0 12]

(ex 1 [0 1 0 1 0 1] A) ;=> expanding along the first dimension
[0  0  0  0
 1  2  3  4
 0  0  0  0
 5  6  7  8
 0  0  0  0
 9 10 11 12]


Take
----
tk

Syntax: (tk <selector> <array>)
<selector> is a numeric vector with one element for each dimension of <array>
<array> an arbitrary array
(p <selector> <=> (rank array))

The result is an array of the same rank where for each dimension the
number of elements specified in the correspondig value in <selector>
is taken from <arra>. If the value in the selector is positive the
elements are taken from the beginning (starting from the lowest
index). If the value is negative the elements are taken from the end
(starting from the highest index). If the value is zero no elements
are taken from the dimension. If more elements are taken than are in
the dimension then the fill elements 0, " " or nil make up the
balance. This latter case is called overtaking. 

for: (tk S A) => R
     (p R) <=> (| S)

Examples:
(setq A (p [3 4] (i 12)))  ;=>
[1  2  3  4
 5  6  7  8
 9 10 11 12]

(tk [2 3] A) ;=>
[1 2 3
 5 6 7]
 
(tk [2 -3] A) ;=>
[2 3 4
 6 7 8]

(tk [-2 -3] A) ;=>
[ 6  7  8
 10 11 12]
 
;; taking zero 
(tk [2 0] A)     ;=> []
(p (tk [2 0] A)) ;=> [2 0]

;; Overtaking examples

(tk [2 7] A) ;=>
[1 2 3 4 0 0 0
 5 6 7 8 0 0 0]

(tk [2 -7] A) ;=>
[0 0 0 1 2 3 4
 0 0 0 5 6 7 8]

(tk 10 "Hello")  ;=> "Hello     "
(tk -10 "Hello") ;=> "     Hello"
(tk 10 $[a b (c d) [1 2] 3 4]) ;=> $[a b (c d) [1 2] 3 4 nil nil nil nil]

Drop
----
dp

Syntax: (dp <selector> <array>)
<selector> is a numeric vector with one element for each dimension of <array>
<array> an arbitrary array
(p <selector> <=> (rank array))
 
The result is an array of the same rank where for each dimension the
number of elements specified in the correspondig value in <selector>
is dropped. If the value in the selector is positive the elements are
dropped from the beginning (starting from the lowest index). If the
value is negative the elements are dropped from the end (starting from
the highest index). If the value is zero no elements are dropped from
the dimension.

for: (dp S A) => R
     (p R) <=> (- (p R) (| S))

Examples:
(setq A (p [3 3] "ABCDEFGHIJ")) ;=>
"ABC
 DEF
 GHI"

(dp [1 0] A)  ;=>
"DEF
 GHI"

(dp [-1 0] A) ;=>
"ABC
 DEF"

(dp [0 1] A) ;=>
"BC
 EF
 HI"

(dp [1 1] A) ;=>
"EF
 HI"

(dp 1 A) ;=>
"EF
 HI"

(dp -1 A) ;=>
"AB
 DE"

;; Dropping a whole dimension
(dp [4 0] A)     ;=> ""
(p (dp [4 0] A)) ;=> [0 3]

(dp 2 A)  ;=> "I"
(dp -2 A) ;=> "A"

(dp 3 (i 10)) ;=>  [4 5 6 7 8 9 10]

(dp -3 (i 10)) ;=> [1 2 3 4 5 6 7]


Rotate array
------------
rot

Syntax: (rot [<axis>] <amount> arg)
Arguments: arg:any array to rotate
           <amount>:num  array number of positions to rotate.
	   <axis>:num singleton axis about which to rotate, default=last axis
	                (onep (e (i {1 (rank arg)}) <axis>))

Function: When <amount> is positive arg is rotated from right
          to left, that is the elments moved out on the left are moved
          in on the right. When <amount> is negative the rotation is
          from left to right. Rotation occurs around the <axis>
          specified or the last axis i.e. (eq <axis> (rank arg))
          When <amount> is a singleton all elements along the axis are
          rotated by <amount>.  When <amount> is not a singleton its
          shape must be the same as that of arg with the axis dimension
          removed. Each element of the <amount> array specifies the
          rotation for the corresponding elements of arg independently.

Returns:   Rotated arg

Examples:

(rot  1 [1 2 3])  ;=> [2 3 1]
(rot -1 [1 2 3])  ;=> [3 1 2]

(a P (p [2 3 4] (i 24)))
P ;=>
[ 1  2  3  4
  5  6  7  8
  9 10 11 12
 
 13 14 15 16
 17 18 19 20
 21 22 23 24]

(rot 1  P) ; rotate columns to the left, default (last) axis =>
[ 2  3  4  1
  6  7  8  5
 10 11 12  9
 
 14 15 16 13
 18 19 20 17
 22 23 24 21]

(rot -1 P) ; rotate columns to the right, default (last) axis =>
[ 4  1  2  3
  8  5  6  7
 12  9 10 11
 
 16 13 14 15
 20 17 18 19
 24 21 22 23]

(rot 2 1 P) ; rotate rows up within each plane, second axis =>
[ 5   6   7   8
  9  10  11  12
  1   2   3   4
 
 17  18  19  20
 21  22  23  24
 13  14  15  16]

(rot 1 1 P) ; rotate planes, first axis =>
[13 14 15 16
 17 18 19 20
 21 22 23 24
 
  1  2  3  4
  5  6  7  8
  9 10 11 12]

(rot 6 "Hello Polly ") ;=> "Polly Hello "

;; It is also possible to rotate each component along the axis by a
;;   specific amount by using a vector or array to specify the amounts

(setq M (p [2 2] (i 4))) =>
[1 2
 3 4]

(rot [0 1] M) => ; rotate only the second row
[1 2
 3 4]
;; This is used for example in when calculating the determinant of a
;; 2nd order matrix  (r '- (r '* 1 (rot [0 1] M)))) => -2


(rot (p [2 3] [1 0 1]) P) ; Rotate alternate rows in each plane
[ 2  3  4  1
  5  6  7  8
 10 11 12  9
 
 14 15 16 13
 17 18 19 20
 22 23 24 21]


(rot 2 (p [2 4] [0 1]) P)) ; Rotate alternate columns in each plane
[ 1  6  3  8
  5 10  7 12
  9  2 11  4
 
 13 18 15 20
 17 22 19 24
 21 14 23 16]

 P => ; for reference P again
[ 1  2  3  4
  5  6  7  8
  9 10 11 12
 
 13 14 15 16
 17 18 19 20
 21 22 23 24]

(rot 1 (p [3 4] [0 1 2 3 3 2 1 0]) P)
[ 1 14  3 16
 17  6 19  8
  9 22 11 24
 
 13  2 15  4
  5 18  7 20
 21 10 23 12]

Transpose
---------
tr

Monadic
Syntax:        (tr <array>)
Type:          subr, APL mixed function
Arguments:     <array>:any array to transpose

Return: The transpose of <array> reversing the dimensions.

(tr A) => res
(eql (p res) (rev (p A)))


Dyadic
Syntax:        (tr <indexes> <array>)
Type:          subr, APL mixed function
Arguments:     <array>:any array to transpose
	       <indexes>:num vector of indexes into the shape vector
	                 of <array> respecting the index origin #IO.
	                 The elements of <indeces> must either all be
	                 unique one for each dimension of <array> or
	                 all equal. 

Return: The transpose of <array> according to the permutation of its
        dimemsions as defined by <indeces>. If the elements of
        <indexes> are all equal to #IO the diagonal of <array> is returned.

(tr V A) => res
(eql (p V) (rank A)) => t
(eql (p res) (aref (p A) V)) => t

Examples:
---------
      (onep #IO) ;=> t
      (setq A (p [5 5] (i 25))) ;=>
[ 1  2  3  4  5
  6  7  8  9 10
 11 12 13 14 15
 16 17 18 19 20
 21 22 23 24 25]

     (tr A) ;=>
[1  6 11 16 21
 2  7 12 17 22
 3  8 13 18 23
 4  9 14 19 24
 5 10 15 20 25]

      (tr [1 1] A) ;=>  ; extract the diagonal
[1 7 13 19 25]

      (setq A (p [2 3 4] (i 25))) ;=>
[ 1  2  3  4
  5  6  7  8
  9 10 11 12
 
 13 14 15 16
 17 18 19 20
 21 22 23 24]



      (tr [2 1 3] A) ;=>
[ 1  2  3  4
 13 14 15 16
 
  5  6  7  8
 17 18 19 20
 
  9 10 11 12
 21 22 23 24]

     (tr [1 3 2] A) ;=>
[ 1  5  9
  2  6 10
  3  7 11
  4  8 12
 
 13 17 21
 14 18 22
 15 19 23
 16 20 24]


Sorting Arrays
--------------
There are two functions for sorting arrays:
gup grade up for sorting in increasing order
gdn grade down for sorting in decreasing order
Each function returns an index vector where the indeces correspond to
the values in the array in the desired order.

Grade Up
--------
gup

Syntax:     (gup <array>)
Type:       subr, APL mixed function
Arguments: <array>:[chr num]

Return: A numeric array of indeces with one element for each element
        in <array> such that the ith element of the result corresponds
        to the index of the ith smallest element in (cat <array>).
	The shape of the result is the same as the shape of <array>.
	The indeces in the result depend on the index origin #IO

Note:   The order of duplicate elements is maintained in the result

Example:
; Set A to a random permutation of the first 10 natural numbers
(setq A (? 10 10)))     ;=> [10 3 6 1 8 5 7 4 2 9] 
(gup A)                 ;=> [4 9 2 8 6 3 7 5 10 1]
(let ((#IO 0)) (gup A)) ;=> [3 8 1 7 5 2 6 4 9 0]
(aref A (gup A))        ;=> [1 2 3 4 5 6 7 8 9 10]
(setq B (p [2 10] A))   ;=> [10 3 6 1 8 5 7 4 2 9
                             10 3 6 1 8 5 7 4 2 9]
(gup B)                 ;=> [4 14 9 19 2 12  8 18 6 16
                             3 13 7 17 5 15 10 20 1 11]
(aref (cat B) (gup B))  ;=> [1 1 2 2 3 3 4 4  5  5
                             6 6 7 7 8 8 9 9 10 10]


(setq A "facetious") ;=> "facetious"
(gup A)              ;=> [2 3 4 1 6 7 9 5 8]
(aref A (gup A))     ;=> "acefiostu"

(gup [8 8 8 8])        ;=> [1 2 3 4]
(gup [6 3 5 3 9 3 1])  ;=> [7 2 4 6 3 1 5]


Grade Down
----------
gdn

Syntax:     (gdn <array>)
Type:       subr, APL mixed function
Arguments: <array>:[chr num]

Return: A numeric vector of indeces with one element for each element
        in <array> such that the ith element of the result corresponds
        to the index of the ith largest element in (cat <array>).
	The shape of the result is the same as the shape of <array>.
	The indeces in the result depend on the index origin #IO

Note:   The order of duplicate elements is maintained in the result

Example:
; Set A to a random permutation of the first 10 natural numbers
(setq A (? 10 10)))       ;=> [2 5 10 1 8 7 3 4 6 9]
(gdn A)                   ;=> [3 10 5 6 9 2 8 7 1 4]
(aref A (gdn A))          ;=> [10 9 8 7 6 5 4 3 2 1]

Fourier Transform
-----------------
w

Inverse Fourier Transform
-------------------------
y

Matrix Inversion
----------------
m/

Encode (Representation of a number in a base)
---------------------------------------------
enc

Syntax: (enc Base Value)

Function: The result is the representation of <Values> in base <Base>

Example:
To represent the decimal value 23 in binary:
(enc [2 2 2 2 2] 23) => [1 0 1 1 1]

Note if the shape of the <Base> is not long enough the most
significant digits of the value are truncated:

(enc [2 2 2 2] 23) => [0 1 1 1]

Different values of the base radices can be used. For example converting
seconds to days, hours, minutes and seconds:

(enc [7 24 60 60] 3723)  => [0 1 2 3] = 1 hour, 2 minutes and 3 seconds
(enc [7 24 60 60] 93784) => [1 2 3 4] = 1 day, 2 hours, 3 minutes and 4 seconds


Decode using base value
-----------------------
dec

Syntax: (dec base values) => res
Type:   subr,
Arguments: base:num:[vector | scalar]
           values:num:[array | scalar]

Funtion: The numeric elements of <values> are evaluated according to
         the base values in <base>. If <base> is a scalar then the
         result is the value of a polynomial in <base> with
         coefficients in <values>. If (lt <Values> <Base>) => t then
         the result is the value of <Values> in base <Base>.

Example:
(dec 7 [2 4 3 1]) => 904 
This is the same as evaluating a polynomial with coefficients [2 4 3 1] with 
the value 7:
(+ (* 2 (exp 7 3)) (* 4 (exp 7 2)) (* 3 (exp 7 1)) (* 1 (exp 7 0))) => 904
It can be used for number conversion. If we want to convert the binary
number 10111 to decimal:
(dec 2 [1 0 1 1 1]) => 23 or (+ 1 2 4 0 16)
If we change the base from 2 to 10 we evaluate the decimal number 10111:
(dec 10 [ 1 0 1 1 1]) => 10111 or (+ 1 10 100 0 10000)

To convert the hexadecimal string FOFF to a number:
(- (ind "0123456789ABCDEF" "F0FF") #IO)       ;=> [15 0 15 15]
(dec 16 (- (ind "0123456789ABCDEF" "F0FF") #IO)) ;=> 61695

A function to perform hexadecimal conversion is provided in lisp/prims.al
(hex "F0FF") ;=> 61695

If <Base> is a vector:
(dec [10 10 10] 5) ;=> 555

To calculate the number of seconds in 1 hour, 2 minutes and 3 seconds:
(dec [ 24 60 60] [1 2 3]) ;=> 3723
Note that the value of the first element of Base does not affect the
computation.

The function below converts the representation of X in base B1 to base B2
(defun conv (X B1 B2) (R0 (enc (p 16 B2) (dec B1 X)))) ;=> conv
(conv [1 0 1 0 0 1 0 1] 2 16) ;=> [10 5]
(dec 16 [10 5])               ;=> 165
(conv [10 5] 16 10)           ;=> [1 6 5]
(dec 2 [1 0 1 0 0 1 0 1])     ;=> 165

The function R0 removes leading zeros from a vector
(see (elimLB) in APL idioms).
(defun R0 (V) (k (s 'v (<> 0 V)) V))

If both <Base> and <Values> are vectors:
;;; make a vector of ascii values
(setq Data  (num "The quick brown fox.")) ;=>
[84 104 101 32 113 117 105 99 107 32 98 114 111 119 110 32 102 111 120 46]
;;; decode as 16 bit (two byte) values
;;; to make the arguments conformant Data must be reshaped to a 2 x n
;;; array preserving the byte order in column major order

(setq R16 (dec [256 256] (tr (p {(/ (p Data) 2) 2} Data)))) ;=>
[21608 25888 29045 26979 27424 25202 28535 28192 26223 30766]
;;; Set the output base to 16 to see more clearly what is going on
(a #OB 16))
Data ;=>  [54 68 65 20 71 75 69 63 6B 20 62 72 6F 77 6E 20 66 6F 78 2E]
R16  ;=>  [5468 6520 7175 6963 6B20 6272 6F77 6E20 666F 782E]
;;; Going the other way... (note the 2 byte columns)
(chr(enc (p 2 256) R16)) ;=>
"Teqikbonfx
 h uc rw o."
;;; Flip the rows and columns with (tr) transpose
(chr (tr (enc (p 2 256) R16)))
"Th
 e 
 qu
 ic
 k 
 br
 ow
 n 
 fo
 x."
;;; Unravel the array with (rav)
(rav (chr (tr (enc (p 2 256) R16))))  ;=> "The quick brown fox."
;;; in 32 bits
(a R32 (dec (p 4 256) (tr (p {(/ (p Data) 4) 4} Data)))) ;=>
R32 ;=>   [54686520 71756963 6B206272 6F776E20 666F782E]
;;; Going the other way... (note the 4 byte columns)
 (chr(enc (p 4 256) R32)) ;=>
"Tqkof
 hu wo
 eibnx
  cr ."
(rav (chr (tr (enc (p 4 256) R32))))  ;=> "The quick brown fox."


Indexing functions

Indexed assignment
------------------
iset

Syntax: (iset <array> <values> <index>)

 iset sets those entries in <array> indexed by  <index> to the
 successive values in <values>
 returns <values>

Function:

   Like (aset) it destructively sets individual values in the <array>
   based on the <index> argument. <index> is a 1 or 2 dimensional
   numeric array. The size of the last dimension of <index>
   determines the number of values to be set. The number of elements
   in value must be <= to the number of indeces. If the number of
   elements in value is less the number of indeces the value argument
   is wrapped.  If dims(<index>) = 2 the number of elements in the
   first dimension of <index> must agree with the rank of the target
   array (eq (rank(<array>) (aref (p <index>) #IO))) => t.  However if
   dims(ind) = 1 and dims(mat) > 1 we repeat the index value for each
   dimension of mat ie if ind=(i N) then we set the diagonal elements
   of mat to sucessive elements of val.

   The types of <array> and <values> must be compatible with the
   exception when <array> is of type ref. In that case the value
   argument is treated as a singleton reference irrespective of its
   shape.
   

Example:
alps: (a A (p [5 5] (i 25)))
alps: A
[ 1  2  3  4  5
  6  7  8  9 10
 11 12 13 14 15
 16 17 18 19 20
 21 22 23 24 25]

alps: (iset A 0 (i 5)) ; set diagonal elements of A to zero
0
alps: A
[ 0  2  3  4  5
  6  0  8  9 10
 11 12  0 14 15
 16 17 18  0 20
 21 22 23 24  0]

(a M (p [10 10] " "))
(iset M "*" (+ 5 (p [2 7] (cat [0 0 0 1 1 2 2]  [0 1 2 0 2 0 2]))))
;=> "*"
M ; a pi heptomino with the upper left hand corner at [5 5] =>
"          
           
           
           
     ***   
     * *   
     * *   


           "

;; Using an <array> of type reference

(setq R (p 5 $[])) ;=> $[nil nil nil nil nil] ; R a reference vector

(iset R [1 2 3] 3) ;=> [1 2 3]

R ;=> $[nil nil [1 2 3] nil nil]

(a R (p 5 $[])) ; reset R

(iset R [1 2 3] [1 3 5]) ;=> [1 2 3]

R ;=> $[[1 2 3] nil [1 2 3] nil [1 2 3]]



Setting values of array elements
--------------------------------
aset

Syntax: (aset <array> <value> <index>)

 aset sets the subarray in <array> described by  <index> to  <value>
 returns <value>
   The shape and rank described by index must be equal to the shape
 and rank of value. <index> must have an entry for each dimension of
 array.

Note: When using aset bear in mind that it modifies the contents of
      the original array. When for example an array is initialised
      with a literal in a program and the array is modified with aset
      such that its value at the end of the program is different from
      the original literal the next execution of the program will have
      that value as the initial value of the array. (see example at
      the end)

Standard syntax example
alps: (a A (p [5 5] (i 25)))
alps: (aset A 123 1 2)
123
alps: (aset A (p [4 5] 22) (i 4) ())
[22 22 22 22 22
 22 22 22 22 22
 22 22 22 22 22
 22 22 22 22 22]

alps: (aset A  (p [5 3] (i 15)) () [1 2 3])
[ 1  2  3
  4  5  6
  7  8  9
 10 11 12
 13 14 15]

alps: A
[ 1  2  3 22 22
  4  5  6 22 22
  7  8  9 22 22
 10 11 12 22 22
 13 14 15 24 25]

(setq A (p [2 3 4] (i 24))) ;=>
[ 1  2  3  4
  5  6  7  8
  9 10 11 12
 
  5  6  7  8
 17 18 19 20
 21 22 23 24]

 (aset A (p [1 2  4 1] (i 8)) () 1 ())
[1
 2
 3
 4
 
 5
 6
 7
 8]

alps: A
[ 1  2  3  4
  5  6  7  8
  9 10 11 12
 
  5  6  7  8
 17 18 19 20
 21 22 23 24]




funky syntax example
(a A (p [5 5] (i 25)))
alps: (aset A 123 [1:2])
123
alps: (aset A (p [4 5] 22) {(i 4):})
[22 22 22 22 22
 22 22 22 22 22
 22 22 22 22 22
 22 22 22 22 22]

alps: (aset A  (p [5 3] (i 15)) [:[1 2 3]])
[ 1  2  3
  4  5  6
  7  8  9
 10 11 12
 13 14 15]

alps: A
[ 1  2  3 22 22
  4  5  6 22 22
  7  8  9 22 22
 10 11 12 22 22
 13 14 15 24 25]

alps: (aset A  (p [5 5] (i 25)) [:])
[ 1  2  3  4  5
  6  7  8  9 10
 11 12 13 14 15
 16 17 18 19 20
 21 22 23 24 25]

; aset with literal array
(defun P () (let ((A [1 2 3 4])) 
       (FOR I 1 3 (print A) (aset A (rot -1 A) ()))))
=>P
(P)
[1 2 3 4]
[4 1 2 3]
[3 4 1 2]
=> 4
(P)
[2 3 4 1]    ; <-------- note output not the same as for first run
[1 2 3 4]
[4 1 2 3]
=> 4
(defun PP () (let ((A {1 2 3 4})) ; using runtime computed literal
       (FOR I 1 3 (print A) (aset A (rot A -1) ()))))
=> PP
(PP)
[1 2 3 4]
[4 1 2 3]
[3 4 1 2]
=> 4
alps: (PP)
[1 2 3 4]   ; <--------  output now the same as for first run
[4 1 2 3]
[3 4 1 2]
=> 4

Getting values of array elements
--------------------------------
aref

Syntax: (aref <array> <index>)

Examples:
(aref [1 2 3] 1)   ;=> 1
(aref [1 2 3] [1]) ;=> [1]

(aref $[1 "hello" (a b c) 4] 3)                 ;=> (a b c)
(aref $[1 "hello" (a b c) 4] [3])               ;=> $[(a b c)]

(aref (p [4 4] $[1 "hello" (a b c) 4]) 3 3)     ;=> (a b c)
(aref (p [4 4] $[1 "hello" (a b c) 4]) 3 [3])   ;=> $[(a b c)]
(aref (p [4 4] $[1 "hello" (a b c) 4]) [3] [3]) ;=> $[(a b c)]

 A
[ 1  2  3  4
  5  6  7  8
  9 10 11 12
 
 13 14 15 16
 17 18 19 20
 21 22 23 24]

(p (aref A 1 [] []))  ;=> [0 0]
(p (aref A [] [] [])) ;=> [0 0 0]
(p (aref A [] [] 1))  ;=> [0 0]
(p (aref A 1 [] 1))   ;=> [0]
(p (aref A 1 1 1))    ;=> []



List assassins
--------------

Discussion:

These functions must be used with some care since they destructively modify
list structure that is possibly referenced by other structures in the
system.

Deleting an element from a list
-------------------------------
delete

Syntax:    (delete arg <list>)

Function: scans down the top level of <list> looking for each element
which is eq to arg removing it by linking the previous element to
the one after it.

(setq L '(a b c (d e) f))  ;=> (a b c (d e) f)
(setq M '(g c h))          ;=> (g c h)
(nconc L M)                ;=> (a b c (d e) f g c h)
L                          ;=> (a b c (d e) f g c h)
(delete 'c L)              ;=> (a b (d e) f g h)
L                          ;=> (a b (d e) f g h)   ; L modified
M                          ;=> (g h)               ; M modified also
;However 
(delete 'a L)              ;=> (b (d e) f g h)
L                          ;=> (a b (d e) f g h)   ; L unchanged


Replacing the head field of a cons cell
---------------------------------------
rplaca

Syntax:    (rplaca <cons> arg)
Function:   Replaces the head field of the <cons> argument with the
            value of arg
Returns:    Value of arg
Example:
(setq L '(a b c (d e) f))  ;=> (a b c (d e) f)
(rplaca L 'First)          ;=> First
 L                         ;=> (First b c (d e) f)
(rplaca (cdr L) 'Second)   ;=> Second
L                          ;=> (First Second c (d e) f)

Replacing the tail field of a cons cell
---------------------------------------
rplacd

Syntax:    (rplacd <cons> arg)
Function:   Replaces the tail field of the <cons> argument with the
            value of arg
Returns:    Value of arg

Example:
(setq L '(a b c (d e) f))  ;=> (a b c (d e) f)
(rplacd L 'Tail)           ;=> Tail
L                          ;=> (a . Tail)
(rplacd L '(new tail))     ;=> (new tail)
L                          ;=> (a new tail)

Smashing lists together
-----------------------
nconc

Syntax: (nconc <list>* [<atom>])
Type: subr

Function: Joins the lists together by changing the last cdr of each <list> to
	   point to the following list. nil arguments are ignored. The last
	   argument can be an atom.

Example:
(setq L '(a b c))            ;=> (a b c)
(nconc L (list 'd 'e 'f))    ;=> (a b c d e f)
L                            ;=> (a b c d e f)
(nconc L (list 'g 'h 'i) 'z) ;=>(a b c d e f g h i . z)


Destructive reverse
-------------------
nrev

Syntax (nrev <list>)
Type: subr

Function: Destructively reverses the <list> provided in the argument by
	   changing the pointers in the cdr's.

Example:
(setq L '(a b c d e f))     ;=> (a b c d e f)
(nrev L)                    ;=> (f e d c b a)
L                           ;=> (a)        ; we have destroyed L
; However
(setq L '(a b c d e f))     ;=> (a b c d e f)
(setq L (nrev L))           ;=> (f e d c b a)
L                           ;=> (f e d c b a)


mapcan - See mapping functions

mapn - See mapping functions


List Manipulation

Finding the length of a list
----------------------------
len


Reversing a list 
----------------
revl

Syntax     (revl <list>)
Type:      subr,list processing
Argument:  <list>:lst
Function: Reverses a copy of the argument <list>
Returns:   The reversed list

Example:
(revl (explod 'very)) ;=> (y r e v)

Substitution of expressions in lists
------------------------------------
subst

Syntax: (subst new old tree)
Type:   subr, list processing
Return: A copy of <tree> where <new> is substituted for <old> wherever
        a subtree or leaf of <tree> is equal to <old>.

Function: Substitutes <new> for every occurrence of <old> in tree
           using the test (equal <old> (subtree <tree>)) to determine
           the occurnence. Note that only fully matched subtrees
           result in a substitution.

Example:
 
(subst 'z '(2 3 hello polly) '(a b c (2 3 hello polly) d e f))
;=> (a b c z d e f)
(subst 'z '(2 3 hello)       '(a b c (2 3 hello polly) d e f))
;=> (a b c (2 3 hello polly) d e f)

Formatting 
----------
fmt

Syntax: (fmt {<num>[:[<field_width>][:[<precision>][:[<base>]]]] |
	      <chr>[:[<field_width>][:<justification>]]}* )
Type: subr, type transformation
Return: A character array in which each argument is formatted
	      according to its specification.


Function: For <num> arguments:

            <field_width> if present specifies the total number of
            characters to be occupied by the formatted argument. If
            <field_width>is negative the field is padded with
	    (| <field_width>) zeros instead of blanks on the left.
	    If <field_width> is zero then the field width uses as
	    many characters as required to format the argument.
	    Constraints: (and (ge (| <field_width> 0))
	    		      (lt (| <field_width 256)))

            <precision> specifies the number of digits following the
            decimal point.  If precision is greater than zero a
            decimal point is produced and <precision> digits follow
            the decimal point.  If precision is equal to zero no
            decimal point is produced.  If precision is less than zero
            as many digits after the decimal point are produced as
            needed.

	    <base> if present specifies the conversion base to be
	    used. If not present it defaults to the value of the
	    system variable #OB.

	    All three specifiers can be vectors. For each successive
	    element in <num> the corresponding specifiers are used.
	    If the number of elements in <num> exceed the number of
	    elements of a specifier the specifier vector wraps. Each
	    specifier vector wraps independently.

          For <chr> arguments

 	    <field_width> if present specifies the total number of
            characters to be occupied by the formatted argument. The
            field is padded with (| <field_width) blanks according to
            the <justification> specifier. If the <field_width>
            specifier is not present or zero the field width is equal
            to the length of the ravel of the <chr> argument:
	    (p (rav <chr>))
	    
	    <justification> specifies how the characters of the
            argument are to be justified into the specified
            field_width.  If justification is less than zero the
            argument is left justified.  If justification is equal to
            zero the argument is center justified.  If justification
            is greater than zero the argument is right justified.
	    If the <justification> specifier is not present the output
            is left justified.

Return: A character vector of the concatenation of the formatted fields.

The maximum number of elements in the result is max_line_len.
<num> args are always right justified.

Examples
--------
(a A 10.123 B "hello")  ; initialise some variables
(fmt A " " A::0 " " A::1)     ;=> "10.123 10 10.1"
(fmt A:8 " " A:8:0 " " A:8:1) ;=> "  10.123       10     10.1"
(fmt A:8 " " A:8:0 " " A:8:-4);=> "  10.123       10 1.0123e1"

(fmt A:9 " " B)       ;=> "   10.123 hello"
(fmt A:9 " " B:10)    ;=> "   10.123 hello     " ; default left justified
(fmt A:9 " " B:10:1)  ;=> "   10.123      hello" ; right justified
(fmt A:9 " " B:10:0)  ;=> "   10.123    hello  " ; center justified
(fmt A:9 " " B:10:-1) ;=> "   10.123 hello     " ; left justified
;; to  left justify the number A use fmt twice
(fmt (fmt A):9:-1 " " B:10:1) ;=> "10.123         hello"

(fmt 123)      ;=> "123"
(fmt -123)     ;=> "-123"
(fmt 123:10)   ;=> "       123"
(fmt -123:10)  ;=> "      -123"
(fmt 123:-10)  ;=> "0000000123"
(fmt -123:-10) ;=> "-000000123"
(fmt (i 10):-5) ; explicit field width zero pad vector
;=> "[00001 00002 00003 00004 00005 00006 00007 00008 00009 00010]"
(fmt (i 10):-5:1) ; field width, zero pad and precision
;=> "[001.0 002.0 003.0 004.0 005.0 006.0 007.0 008.0 009.0 010.0]"

;; Vector example
(setq A (/ (i 10) 10)) ;=> [.1 .2 .3 .4 .5 .6 .7 .8 .9 1]
; automatic field width
(fmt A::2) ;=>  "[.10 .20 .30 .40 .50 .60 .70 .80 .90 1.00]"
(fmt A:5:2) ; explicit field width
;=> "[  .10   .20   .30   .40   .50   .60   .70   .80   .90  1.00]"
(fmt A:-5:2) ; and pad with zeros
;=> "[00.10 00.20 00.30 00.40 00.50 00.60 00.70 00.80 00.90 01.00]"
(fmt A:6:-1) ; with exponent notation
"[1.0e-1 2.0e-1 3.0e-1 4.0e-1 5.0e-1 6.0e-1 7.0e-1 8.0e-1 9.0e-1  1.0e0]"

(FOR I 1 6  (princ (fmt (i 10):I "\n"))) => ; variable field width spec
[1 2 3 4 5 6 7 8 9 ?]
[ 1  2  3  4  5  6  7  8  9 10]
[  1   2   3   4   5   6   7   8   9  10]
[   1    2    3    4    5    6    7    8    9   10]
[    1     2     3     4     5     6     7     8     9    10]
[     1      2      3      4      5      6      7      8      9     10]
;=> 7
;; variable  precision
(FOR I 0 6 (princ (fmt [12345 1.2345 12345e3]:12:(- I 3) "\n")))
[     1.235e4      1.234e0      1.235e7]
[      1.23e4       1.23e0       1.23e7]
[       1.2e4        1.2e0        1.2e7]
[       12345            1     12345000]
[     12345.0          1.2   12345000.0]
[    12345.00         1.23  12345000.00]
[   12345.000        1.234 12345000.000]
;=> 7

;; Note that for the first and last values of the middle column
(fmt 1.2345:-3) ;=> "1.234e0" ; rounding up should give "1.235e0"
(fmt 1.2345::3) ;=> "1.234"   ; rounding up should give "1.235"
;; This is because the internal IEEE 754 representation of 1.2345
;; is slightly less than 1.2345 
;; The same digits are rounded correctly if multiplied or divided by 10
(fmt 12.345::-3) ;=> "1.235e1"
(fmt .12345::-3) ;=> "1.235e-1"
;; By default, for unformated fields, the number of significant digits
;; is 10
#SD     ;=> 10
1.2345  ;=> 1.2345
;; Setting it to 17 reveals the internal representation
(a #SD 17)
12.345 ;=> 12.345000000000001
1.2345 ;=> 1.2344999999999999
.12345 ;=> .12345
;; Adding 1e-15 to the number:
1.234500000000001 ;=> 1.234500000000001
(fmt 1.234500000000001::-3) ;=> "1.235e0"
(fmt 1.234500000000001::3)  ;=> "1.235"

;; Using vector specifiers to print a table of number conversions
;; for binary, octal, decimal and hexadecimal [2 8 10 16]

(FOR I 1 16 (princl (fmt (p 4 I):[5 3 3 3]::[2 8 10 16]))) ;=> 17
    1  1  1  1
   10  2  2  2
   11  3  3  3
  100  4  4  4
  101  5  5  5
  110  6  6  6
  111  7  7  7
 1000 10  8  8
 1001 11  9  9
 1010 12 10 0A
 1011 13 11 0B
 1100 14 12 0C
 1101 15 13 0D
 1110 16 14 0E
 1111 17 15 0F
10000 20 16 10

;; To print a compact table of number base conversions for values 1 to
;; 32 with bases 2 to 16. Note use of logs (l) to determine max field
;; width for each column.

(FOR I 1 32 (princl (fmt (p 15 I):(+ 1 (c(l (i [2 16]) 32)))::(i [2 16]))))

;; Using a variable field_width

(FOR I 0 12 (princl (fmt I:3 "  " -15611.6789:I)))
  0  -15611.6789
  1  ?
  2  -?
  3  -2?
  4  -2e4
  5   -2e4
  6  -15612
  7   -15612
  8  -15611.7
  9  -15611.68
 10  -15611.679
 11  -15611.6789
 12   -15611.6789

;; fmt of fmt
(apply 'fmt (mapcar 'fmt (explod (i 7)))) ;=> "1234567"

Lisp negation
-------------
not

Syntax: (not arg)
Type:   subr, lisp logical
Return: If arg evaluates to nil it returns t else it returns nil

Examples:
(not nil)      ;=> t
(not '(a b c)) ;=> nil

Pushing values onto a stack
---------------------------
push

Syntax: (push <exp> <sym>)
Type:   subr, binding
Return: (eval <exp>)

Function: The value of <exp> is prepended to the value of the symbol
           symbol <sym>.  The side effect of the expression
	    (push <exp> <sym>) is equivalent to that of the expression 
	    (set <sym> (cons <exp> (eval <sym>))). If the symbol is
           unbound a value of nil is used.
	   

Note: The alps implementation of push evaluates the second argument whereas in
      emacs lisp does not.

Example:
alps: (setq S nil)   ; here the symbol S will hold the stack
nil
alps: (push 'dog 'S)
dog
alps: (push 'lazy 'S)
lazy
alps: (push 'the 'S)
the
alps: (push 'over 'S)
over
alps: S
(over the lazy dog)
alps: (set 'S (cons 'jumps (eval 'S)))
(jumps over the lazy dog)


Popping values off a stack
--------------------------
pop

Syntax: (pop <sym>)
Type:   subr, binding
Return: The car of the value of the symbol <sym>.

Function: The value of the symbol <sym> is set to the cdr of its
	   original value. The car of the original value is returned
	   as the result. The side effect of the expression 
	   (pop <sym>) is equivalent to that of
	   (set <sym> (cdr (eval<sym>))). If the symbol was bound to
	   an atom at the first (push) that value will be returned for
	   every pop of the empty stack.

Note: The alps implementation of pop evaluates its argument whereas in
      emacs lisp it is not.

Example: 
S        => (jumps over the lazy dog)
(pop 'S) => jumps
(pop 'S) => over
S        => (the lazy dog)
(set 'S (cdr (eval 'S))) => (lazy dog)
(pop 'S) => lazy
(pop 'S) => dog
(pop 'S) => nil
(pop 'S) => nil

(setq S 'hello)
(push 'fox 'S)
(push 'quick 'S)
(push 'The 'S)
(pop 'S) => The
(pop 'S) => quick
(pop 'S) => fox
(pop 'S) => hello
(pop 'S) => hello


Clearing unused variables
-------------------------
If the values of certain symbols are no longer required and one wishes
to recover the memory space they occupy the function
(clear Symbol1 Symbol2 ... Symboln) can be used. Once a symbol has
been cleared it becomes unbound and its previous value irretrievable.

clear

Syntax:    (clear <Symnol>+)
Type:      fsubr, binding
Arguments: zero or more Symbols

Function: If no arguments are given *all* symbols are cleared without
	  warning. Otherwise for each non system symbol argument the
	  value associated with the symbol is cleared in the current
	  environment. In other words it becomes unbound in that
	  environment. For system symbols (e.g. #PP) the symbol is
	  reset to its initial value. When using (clear) with no
	  arguments be aware that important system variables that are
	  set up on start-up such as #LP - load path - or #HS the
	  command history will be reset to nil.

Return:   t if all arguments were valid symbols else nil.

Example:
	  
(setq A 1 B 2 C 3 car 4 cdr 5) ;=> 5
(list A B C car cdr)           ;=> (1 2 3 4 5)
(clear A B C car cdr)          ;=> t
(list A B C car cdr)            => ERROR: Unbound symbol: A

(setq A 1 B 2 C 3 car 4 cdr 5) ;=> 5  ;;  set symbol values again
;; bind symbols to new values in a new environment
(let ((A 'a) (B 'b) (C 'c) (car 'd))
  (print (list A B C car cdr))
  (clear C cdr)
  (boundp 'C)) ;=> nil
=> (a b c d e)
(list A B C car)           ;=> (1 2 3 4) 
;; Note that C was only unbound in the new environment
cdr      ;=> ERROR Unbound symbol: cdr
;; However since cdr was not bound in the new enviroment it
;; was cleared in the old environment.
(clear t)    ;=> nil       ;; t is not a valid symbol
(clear nil)  ;=> nil       ;; nil is not a valid symbol


gclear
goff
gon
genable
gdisable
trace
sort

Data conversion

Converting character data to numerics
num
---

Syntax: (num <chr>)
        Where <chr> is an array of type chr.

Function: Produces a numeric array of the same shape as the <chr>
	   argument where each numeric element contains the numeric
	   ASCII code of the corresponding character element in the
	   argument.


Examples:

(num "abc") => [97 98 99]

(num (p [3 3] "CatSatMat")) => 
[67 97 116
 83 97 116
 77 97 116]

(num "") => []

Converting numeric data to characters
chr
---

Syntax: (chr <num>)
        Where <num> is an array of type num.

Function: Produces a character array of the same shape as the <num>
	   argument where each character element is the ASCII
	   character represented by the ASCII code in the
	   corresponding element modulus 256 in the argument. 

Examples:

(chr (+ 96 (i 10))) => "abcdefghij"

alps: (chr (p [3 3] [67 97 116 83 97 116 77 97 116])) => 
"Cat
 Sat
 Mat"

(chr []) => ""

The two functions cap and low defined in prims.al use the
primitives num and chr to convert to Upper and Lower case
respectively:

(defun low (X) ; convert char arg to lower case
  (let ((N (num X))) (chr (+ N (* 32 (^ (> N 64) (< N 91)))))))

(defun cap (X)  ; convert char arg to upper case
  (let ((N (num X))) (chr (- N (* 32 (^ (> N 96) (< N 123)))))))

(cap "Function") => "FUNCTION"
(low "Function") => "function"


Data structure conversion
-------------------------
Discussion

The following two functions are used to convert between lists and
arrays.  (implod) takes a list argument and tries to create an array
from the elements of the list. (explod) "explodes" an array or symbol
argument into a list of its constituent elements or characters.

Imploding a list to an array
----------------------------
implod

Syntax: (implod [axis [flag]] <list> )
Type: subr, type conversion
Arguments: <list> is a list of elements. If flag is nil they must be of
           the same type. If they are of the same type the optional
	   axis argument can be used to determine the shape of the
	   resulting array.

	   axis: optional argument specifying the axis for implosion.
	   If axis is positive integer the implosion occurs along that
	   axis as referred to in the elements of <list>
	   If axis is a positive non-integer then the implosion occurs
	   along a new dimension which is between (f axis) and
	   (c axis)
	   If the axis argument is negative then the effective
	   positive axis of the implosion is
	   (+ axis (rank (elements of <list>)) + 1)
	   To implode the elements of <list> along a new dimension after the
	   last an axis argument of -.5 can always be used.
	   The axis argument cannot be zero.
	   When the axis argument is supplied all the elements of <list>
	   must have the same type and shape except in the dimension
	   along which the implosion is to occur.
	   For the case where a reference array is required the axis
	   argument must be set to nil.

	   flag: t | nil 
	   When flag it t a vector of type reference is created
	   from <list> with as many elements as are in <list>.
	   When flag is nil  the type and shape are determined by
	   the type of the first element of <list>. If the first
	   element in <list> is of type reference all elements of
	   <list> of type reference are treated as arrays.
	   flag cannot be t when an axis is specified.

Function:  implod catenates together all the elements in <list>
            Without the axis argument it behaves like repeated
	    catenation on the elements of the list.
	    When an axis argument is specified the catenation takes
	    place along that axis.

Examples:

(implod '(1 2 3 4 5 [6 7 8] 9 10))  ;=> [1 2 3 4 5 6 7 8 9 10]
(implod '("abc" "d" "efg" h ij))    ;=> "abcdefghij"

;; Let L1 be a list of 2 by 3 matrices with all elements of the
;; matrix equal and increasing by 1 for each successive matrix in
;; the list
;; (setq L1 (mapcar '(lambda (X) (p [2 3] X)) '(1 2 3 4 5))) ;=>
([1 1 1
  1 1 1]

 [2 2 2
  2 2 2]

 [3 3 3
  3 3 3]

 [4 4 4
  4 4 4]

 [5 5 5
  5 5 5]
)
;;(implod L1) ;=> implode along last dimension
[1 1 1 2 2 2 3 3 3 4 4 4 5 5 5
 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5]
;; (implod 2 L1) ;=> 2 is the last dimension of the elements of L1
[1 1 1 2 2 2 3 3 3 4 4 4 5 5 5
 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5]
;; (implod 1 L1) ;=> implode along the first dimension
[1 1 1
 1 1 1
 2 2 2
 2 2 2
 3 3 3
 3 3 3
 4 4 4
 4 4 4
 5 5 5
 5 5 5]

;; (p (implod .5 L1))  ;=> [5 2 3]
;;       gives a 5 by 2 by 3 array with new dimension before the first
;; (p (implod 1.5 L1)) ;=> [2 5 3]
;;        gives a 2 by 5 by 3 array with new dimension between 1 and 2
;;(p (implod 2.5 L1)) ;=>  [2 3 5]
;;        gives a 2 by 3 by 5 array with new dimension after the last:
;;(p (implod -.5 L1))  ;=> [2 3 5] gives the same result as above since
;;        the -.5 axis argument implies implosion after the last
;;       dimension
;; (implod -.5 L1) ;=>
[1 2 3 4 5
 1 2 3 4 5
 1 2 3 4 5
 
 1 2 3 4 5
 1 2 3 4 5
 1 2 3 4 5]

;; (explod L) is effectively the inverse of (implod -.5 L)
;; (equal (explod (implod -.5 L1)) L1) ;=> t

(implod .5 '(aa bb cc)) ;=>
"aa
 bb
 cc"

;;(implod () t '(a 1 "asd" (hello polly) [1 2 3])) ;=>
$[a 1 "asd" (hello polly) [1 2 3]]

;; (implod nil nil '(1 2 3 4)) ;=> [1 2 3 4]
;; (implod nil t   '(1 2 3 4)) ;=> $[1 2 3 4]
;; (implod .5  nil '(1 2 3 4)) ;=>
[1
 2
 3
 4]

;; (implod nil)         ;=> []
;; (implod nil nil nil) ;=> []
;; (implod nil t nil)   ;=> $[]

;; Implosion with reference arguments
;; setting the flag always produces a reference vector of each element
(implod () t (list  [1 2 3] [1 2 3])) ;=> $[[1 2 3] [1 2 3]]

(setq L (list $[1 2 3 "abc"] $[c d e f] 1 [1 2 3] '(hello polly) 'a))
(implod () t L) ;=> $[$[1 2 3 "abc"] $[c d e f] 1 [1 2 3] (hello polly) a]
(p (implod () t L)) ;=> 6
(len L)             ;=> 6

;; without the flag => repeated catenation
(implod (list  [1 2 3] [1 2 3]))
[1 2 3 1 2 3]

;; when first element is a reference all non reference arguments are
;; treated as singletons
(implod (list  $[1 2 3] [1 2 3])) ;=> $[1 2 3 [1 2 3]]
;; with the flag set each element is treated as a singleton
(implod () t (list  $[1 2 3] [1 2 3]))  ;=> $[$[1 2 3] [1 2 3]]
(implod () t (list  $[1 2 3] $[1 2 3])) ;=> $[$[1 2 3] $[1 2 3]]
(implod (list  $[1 2 3] $[1 2 3]))      ;=> $[1 2 3 1 2 3]

(implod () (list [1 2 3] $[1 2 3])) => ERROR
Improper function argument: incompatible types
(implod () (list $[] [1 2 3] $[1 2 3])) ;=> $[[1 2 3] 1 2 3]

Exploding an array into a list
------------------------------
explod

Syntax: (explod [axis] arg)

Type: subr, conversion

Function:

Examples:

(explod (i 10))        ;=> (1 2 3 4 5 6 7 8 9 10)
(explod "Hello Polly") ;=> ("H" "e" "l" "l" "o" " " "P" "o" "l" "l" "y")
(explod 'BOMB)         ;=> (B O M B)

(setq R (p (dp 1 (i 4)) (i (! 4)))) ;=>
[ 1  2  3  4
  5  6  7  8
  9 10 11 12
 
 13 14 15 16
 17 18 19 20
 21 22 23 24]

(explod 3 R)  ;=>
([ 1  5  9
  13 17 21]

 [ 2  6 10
  14 18 22]

 [ 3  7 11
  15 19 23]

 [ 4  8 12
  16 20 24]
) 

(explod 2 R) =>
([ 1  2  3  4
  13 14 15 16]

 [ 5  6  7  8
  17 18 19 20]

 [ 9 10 11 12
  21 22 23 24]
)

(explod 1 R)
([1  2  3  4
  5  6  7  8
  9 10 11 12]

 [13 14 15 16
  17 18 19 20
  21 22 23 24]
)

(explod R) ;=> (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24)

(r '+ -1 R) =>                ; plus reduction  along last axis
[10 26 42
 58 74 90]

(apply '+ (explod -1 R))      ; apply plus to list exploded along last axis
[10 26 42
 58 74 90]


Mapping functions on lists
--------------------------
Discussion

Mapping functions are very useful for applying a function to a list
and each of its successive cdrs or to each element of a list. Some
cons together the results in a list (mapcar maplist), others collect
the non-nil results by (nconc)-ing them together, yet others
return the result of a particular application (gen genc ngen ngenc),
these (map and mapc) just return nil and these (find findc) return a
position in the list argument. 

Here is a summary of the mapping functions
The general form for the mapping functions is: (<mapfn> <funk> <list>)

map     applies funk to list and successive cdr's of list (side effect only)
mapc    applies funk to successive car's of <list> (side effect only)
maplist	conses results of applying funk to <list> and successive cdr's
mapcar  conses results of applying funk to successive car's of <list>
mapn    nconcs results of applying funk to <list> and successive cdr's
mapcan  nconcs results of applying funk to successive car's of <list>
gen     applies <funk> to  <list> and successive cdr's until the first
	nil result or the result of the last application
genc    applies <funk> to successive car's of <list> returns the first
	nil result or the result of the last application
ngen    applies <funk> to  <list> and successive cdr's returns the
        first non-nil result or nil if all results were nil.
ngenc   applies <funk> to successive car's of <list> returns the
	first non-nill result or nil if all results were nil.
find    applies <funk> to <list> and successive cdr's of <list>
	returning the argument to <funk> that produced a result that is
	(eq) to	the additional <match> argument, or nil	     
findc   applies <funk> to successive car's of <list> returning the
        list the to which <funk> applied to the (car) produced a
	result that is (eq) to the additional <match> argument, or nil	
       

Mapping 
-------
map

Syntax: (map <funk> <list>+)
Type: subr, Mapping
Arguments: <funk>:subr|expr
Function: applies funk to the <list> arguments and their
          successive cdr's until the shortest <list> argument is
	  exhausted. Used for side effect only.

Returns: nil	  

Example
-------

 (map '(lambda (X Y) (print (list X Y))) '(a b c d e) '(1 2 3 4))
((a b c d e) (1 2 3 4))
((b c d e) (2 3 4))
((c d e) (3 4))
((d e) (4))
nil

Mapping with cars
-----------------
mapc

Syntax: (map <funk> <list>+)
Type: subr, Mapping
Arguments: <funk>:subr|expr
Function: Applies funk to the successive cars of the <list> arguments
          until the shortest <list> argument is exhausted.
	  Used for side effect only.

Returns: nil	  

Example
-------

(mapc '(lambda (X Y) (print (list X Y))) '(a b c d e) '(1 2 3 4))
(a 1)
(b 2)
(c 3)
(d 4)
=>nil

Map collecting results
----------------------
maplist

Syntax: (maplist <funk> <list>+)
Type: subr, Mapping
Arguments: <funk>:subr|expr
Function: Applies funk to the <list> arguments and their
          successive cdr's until the shortest <list> argument is
	  exhausted. 

Returns: The results of each application are returned in a list

Example
-------
(maplist '(lambda (X Y) (list X Y)) '(a b c d) '(1 2 3)) ;=>
(((a b c d) (1 2 3)) ((b c d) (2 3)) ((c d) (3)))


Map with cars collecting results
--------------------------------
mapcar

Syntax: (mapcar <funk> <list>+)
Type: subr, Mapping
Arguments: <funk>:subr|expr
Function: Applies funk to the successive cars of the <list> arguments
          until the shortest <list> argument is exhausted.

Returns: The results of each application are returned in a list

Example
-------
(mapcar '(lambda (X Y) (list X Y)) '(a b c d) '(1 2 3)) ;=> ((a 1) (b 2) (c 3))


Map collecting results (destructive)
------------------------------------
mapn

Syntax: (mapn <funk> <list>+)
Type: subr, Mapping
Arguments: <funk>:subr|expr
Function: Applies funk to the <list> arguments and their
          successive cdr's until the shortest <list> argument is
	  exhausted. Each application must return a list value.

Returns: The results of each application are nconc'ed together to
         produce the result.

Example
-------
(mapn '(lambda (X Y) (list X Y)) '(a b c d) '(1 2 3)) ;=>
((a b c d) (1 2 3) (b c d) (2 3) (c d) (3))

Map with cars collecting results (destructive)
----------------------------------------------
mapcan

Syntax: (mapcan <funk> <list>+)
Type: subr, Mapping
Arguments: <funk>:subr|expr
           <list>:lst

Function: Applies funk to the successive cars of the <list> arguments
          until the shortest <list> argument is exhausted. Each
	  application must return a list value. 

Returns: The results of each application are nconc'ed together to
         produce the result.

Example
-------
(mapcan '(lambda (X Y) (list X Y)) '(a b c d) '(1 2 3)) ;=> (a 1 b 2 c 3)

Generalisation
--------------
gen

Syntax:  (gen <funk> <list>+)
Type: subr, Mapping
Arguments: <funk>:subr|expr
           <list>:lst
Function: applies funk to the <list> arguments and their
       successive cdr's until (null (funk arg+)) whereupon it returns
       nil. If no application of funk returns nil the value of the
       last application is returned. The application is terminated as soon
       as any of the list arguments is exhausted.

Returns: nil if an application of funk returns nil
         value of application of funk to the last element(s) of the
         list arguments.

Note: gen works like (and) on the result of mapping <funk> on the
      <lists> and their successive cdr's.

Example
-------
(gen '(lambda (X) (print X) (car X)) '(A B C D E) )
(A B C D E)
(B C D E)
(C D E)
(D E)
(E)
=> E
(gen '(lambda (X) (print X) (car X)) '(A B () C D E) )
(A B nil C D E)
(B nil C D E)
(nil C D E)
=> nil
     
Generalisation with cars
------------------------
genc

Syntax: (genc <funk> <list>+)
Type: <subr>,mapping
Arguments: <funk>:subr|expr
           <list>:lst
       applies funk to successive car's of list until 
       (null (funk (car arg))) whereupon it returns nil. If no
       application of funk returns nil the value of the last
       application is returned.

Note: genc is similar to the common lisp function (every)
      genc works like (and) on the result of mapping <funk> on the
      successive car's of the <lists>.

Example
-------
(genc 'arg '(A B C D E) ) ;=> E
(genc 'arg '(A B () C D E)) ;=> nil

;; Matching the start of a list
(genc 'equal  '(lambda (X Y)) '(lambda (X Y) (print Y))) ;=> t



In general (genc 'fun (list A B C ..)) is equivalent to
           (and (fun A) (fun B) (fun C) ..))

Defining subset using genc
(de subsetq (A B) (genc '(lambda (X) (memq X B)) A)) ; are all A's in B
;=> subsetq

(subsetq '(c e g) '(a b c d e f g h i)) ;=> (g h i)
(subsetq '(c e g j) '(a b c d e f g h i)) ;=> nil


Negated Generalisation
----------------------
ngen

Syntax:  (ngen <funk> <list>+)
Type: subr, Mapping
Arguments: <funk>:subr|expr 
           <list>:lst
Function: Applies <funk> to the <list> arguments and their
          successive cdr's until (not (null (funk arg+))) whereupon it
	  returns the value of the application. If no application of
	  <funk> returns a non-nil value nil is returned. The
	  application is terminated as soon as any of the list
	  arguments is exhausted.

Returns: The value of the first application of funk which is not nil.
	 otherwise nil.



Negated Generalisation with cars
--------------------------------

ngenc
Syntax: (ngenc <funk> list+)
Type: subr, Mapping
Arguments: <funk>:subr|expr
           <list>:lst
Function: Applies <funk> to successive car's of the <list> arguments until 
       (not (null (<funk> (car arg)+ )) whereupon it returns the value of
       the application. If no application of function returns a non-nil
       value, nil is returned.

Returns: The value of the first application of funk which is not nil.
	 otherwise nil.


Note: ngenc is similar to the common lisp function (some)
      ngenc works like (or) on the result of mapping <funk> on the
      successive car's of the <lists>.

Example
-------
(ngenc 'arg '(A B C D E) ) ;=> A
(ngenc 'arg '(nil nil nil) ) ;=> nil

In general (ngenc 'fun (list A B C ..)) is equivalent to
           (or (fun A) (fun B) (fun C) ..)
Define any using ngenc
(de any (A B) (ngenc '(lambda (X) (memq X B)) A)) ; Are any A's in B
;=> any
(any '(j k l) '(a b c d e f g h i)) ;=> nil
(any '(i j k l) '(a b c d e f g h i)) ;=> (i)

Finding an element in a list
----------------------------
find

Syntax: (find <funk> <list> <match>)
Type: subr, Mapping
Arguments: <funk>:subr|expr
           <match>:any

Function: Applies funk to <list> and successive cdr's of <list> until
          (eq  (funk arg) <match>) whereupon it returns arg

Returns: <list> starting from the first element for which the application of
         <funk> is eq to <match> otherwise nil.



Finding an element in a list with cars
--------------------------------------
findc
Syntax: (findc <funk> <list> <match>)
Type: subr, Mapping
Arguments: <funk>:subr|expr
           <match>:any
Function: Applies funk to successive car's of <list> until
         (eq  (funk (car arg)) <match>) whereupon it returns arg

Returns: <list> from the first element for which the application of
         <funk> is eq to <match> otherwise nil.
	 
Example:
--------
(findc '(lambda (X) (eq X 'c)) '(a b c d) t) ;=> (c d)
(findc '(lambda (X) (eq X 'e)) '(a b c d) t) ;=> nil


Input and Output Functions
--------------------------

Reading an atom
---------------
ratom

Syntax: (ratom [file])
Type:   <subr>, Lisp reader
Arguments: file:[fil | buf]

Function: Reads an atom from <file>. If it is the comment symbol <;>
          it is ignored and the rest of the line up to the new-line
          character is discarded. The new-line character is treated as
          a space. (ratom) continues reading until it finds an atom.
	  
Returns: Returns the atom read from <file>.
 	 If <file> is in the end-of-file condition it returns nil.

Examples:

(ratom)
xx           
;=> xx
(ratom)
                            ;; newline(s) or <;>
; blah blah

yy
;=> yy

(ratom)
[

1 2
3

; blah blah
4

]
;=> [1 2 3 4]

;; When ratom reads a left open bracket it returns the
;; left open bracket symbol
(ratom)
(
;=> (
;; It is not possible to quote an open bracket so to test for an open
;; bracket symbol:
(eq (intern "(") (ratom))
(
;=> t


Reading an s-expression
-----------------------
read

Syntax: (read [file])
Type:   <subr>, Lisp reader
Arguments: file:[fil | buf]

Function: Reads an s-expression from <file>. If the comment symbol <;>
          is encountered the rest of the line up to the new-line
          character is discarded. (read) treats new-line characters as
          spaces and will only return once it has found at least an
          atom or a complete s-expression. The characters following
          the end of the s-expression on the line are kept for the
          next read operation.
	  
Returns: Returns the s-expression read from <file>. On the end-of-file
         condition it signals an error.

Examples:


(read)
a
;=> a

(read)
(a b c)
;=> (a b c)

;; assign values to b and c to demonstrate the effect of remaining
;; after the first s-expression read.
alps: (a b "this is b" c "this is c")
alps: (read)
a b c
;=> a                ;; read returns the first s-expression a
alps: "this is b"    ;; b and c are read and evaluated by the
alps: "this is c"    ;; prompt-read-eval-print loop
alps:

;; create a buffer E containing an incomplete s-expression
(a E (buf "(this is a list"))
(read E) => Invalid expression:  (..) unexpected EOF in : buf
;; create a buffer E containing a complete s-expression
(a E (buf "(this is a list)"))
(read E)  ;=> (this is a list)


Reading the atoms on a line
---------------------------
readl

Syntax: (readl [file])
Type:   <subr>, Reader
Arguments: file:[fil | buf]

Function: Makes a list of atoms read from <file> until it encounters a
	  new-line character or an end-of-file condition.  If it
	  encounters the comment symbol <;> it is treated as an
	  end-of-line.
	  
	  
Returns: For a non-empty line it returns the list of atoms read from an
         input line from <file>. On an empty line (containing only the
         new-line character) or on the end-of-file condition it returns
	 nil.

Examples:
(readl)
1 2 3 hello bye
;=> (1 2 3 hello bye)
(readl)
1 2 3 ;hello bye
;=> (1 2 3)
(readl)
                                       ;; new-line
;=> nil

(readl)
; blah blah
;=> nil

Raw Input Output
----------------

Discussion

The raw input primitives return the contents of the input file without
modification. (getc) reads a character, (getl) reads a line and
(getb) reads a specified number of characters.

(getc) is useful for file parsing of an input file or user
interaction with a keyboard.

(getl) is useful for file processing and reading a line of raw input.

The output primitive (putb) writes its character argument to the
file.

(getb) and (putb) are useful when raw data needs to be transfered to
and from instrument devices such as a meter or oscilloscope over a
serial or USB connection. For GPIB instruments the special GPIB
primitives must be used (see GPIB IO).
 

Reading the next raw character in a file
----------------------------------------
getc

Syntax: (getc [file])
Type:   <subr>, File I/O
Arguments: file:[fil | buf]
	   #RF implicit argument

Function: Reads the next character from <file>. If <file> is not
	  specified it reads from the current input file #RF.
	  
Returns: If not at the end of <file> it returns the next character in
	 the file as a character singleton. The characters are the raw
	 characters from the file including all ASCII codes from 0 to
	 255.
	 If at the end of <file> it returns nil.


Example:
(getc)
x
;=> "x"

Note: The character singletons returned by (getc) are (eq) to the
      corresponding character literal. If the character x is typed
      when evaulating (eq (getc) "x") the result is t.
      
Reading the characters of a line
--------------------------------
getl

Syntax: (getl [file [eol-char]]) => res
Type:   subr, file I/O
Arguments: file:flk
           eol-char:chr:singleton
	   #RF implicit argument

Function: If no parameters are given (getl) reads from the default
          input file #RF and uses "\n" as the end-of-line character.
	  (getl) reads characters from <file> until either
	  the end-of-line character or
	  end-of file condition or
	  maximum line length is encountered.
	  The maximum line length is at least 1024 characters.
	  
Returns If <file> is not in the end of file condition it returns a
        character vector containing the characters from an input line
        from <file>. The end-of-line character is not included in the
        vector. If the file does not contain a eol-char as the last
	byte the vector will contain the characters from the last
	end-of-line character up to the end of the file.
	If <file> is in the end-of-file condition (getl) returns  nil.

Example: (getl)
1 2 3 hello bye
;=> "1 2 3 hello bye"


Reading a number of characters from a file
------------------------------------------
getb

Syntax: (getb file count) => res
Type:   subr, file I/O
Arguments: file:flk
	   count:num:singleton
	   
Function: Reads <count> characters from <file>.

Returns: A character vector of up to <count> elements.
	 If fewer than <count> characters remain in the file (getb)
	 returns the vector of remaining characters.
	 If the file is in the End-Of-File condition nil is returned.

Outputting a character array to a file
--------------------------------------
putb

Syntax: (putb arg1 file) => res
Type:   subr, file I/O
Arguments: arg1:chr:array
	   file:fil


Function: Writes the ravel of arg1 to <file> at the current position.

Returns: t if successful else nil.

Controlling IO
--------------
ioctl

Syntax: (ioctl <file> <cmd> [arg])
Where: <file> is a file object
       <cmd> is a scalar representing the operating system control
       command
       arg is an optional scalar to be passed to the ioctl call

Function: Performs a system ioctl call on the file descriptor
           associated  with file with the parameters passed as
	   unsigned integers.

Return:    If the call fails nil is returned.
           If arg is present the value of arg as modified by the
           call is returned
	   else t is returned.

Example:
(a SCOPEF (open "/dev/usbtmc0")) ; open file associated with an instrument
(ioctl SCOPEF (hex "80015B12") 0) => 129 ; status byte 


Printing
--------

Discussion:

The primitives (print), (prin0) and (pp) print their
arguments in a way that the output can be read by the alps reader. In
other words character objects are printed with double quotes, numeric
vectors with square brackets etc. In order to precisely control the
characters printed the primitives (princ) and (prat) print their
arguments without quotes or square brackets. They will however
preserve list structure by printing parens around lists. The primitive
(prinl) can be used to suppress the printing of the first level of
parens, it is typically used to print a simple list of atoms without
the enclosing parens.

The formatting of how numeric arguments are printed is controlled by
system variables. The formatting of mixed data types is done with the
primitive (fmt) described in the formatting section.

The system variables controlling the formatting of numeric items are
as follows:

#FW is the field width.

By default it is zero which tells the system to calculate an
appropriate field width. In general the system attempts to keep output
compact.

If #FW is positive each number is printed right justified in a field
of #FW characters with leading blanks. 

If #FW is negative each number is printed right justified in a field
of (| #FW) characters with leading zeros.

#PP is the print precision.

It specifies how many digits should appear after the point. By default
#PP is -1 which indicates that the system should use the number of
significant digits specified by #SD to determine how many places to
print after the point. If the number of digits required to represent
the value exceeds #SD, exponent notation is used.

If #PP is less than -1 it forces exponent notation.

If #PP is greater or equal to zero precisely #PP digits are printed
after the point. If the actual number of digits after the point is
greater than #PP the last printed digit is rounded up.

#EP is the print precision for exponent notation.

By default it is -1 which indicates that the system should determine
how many digits to print afer the point. The smallest number of digits
will be printed up to the maximum determined by #SD.

#SD is the number of significant digits

By default it has a value of 10.

If #SD is greater or equal to zero a maximum of #SD digits will be
produced for each number except for the case of #SD = 0.
In that case exponent notation is used with 1 significant digit.

If #SD is negative the number of digits is determined by the
number of digits of the output base that can be represented by 53
bits.

#OB is the output base

By default it has a value of 10. It can be set to any value between 2
and 16 inclusive. Note that the input base is controlled separately
with #IB.

Note that the prompt-read-eval-print function of the built-in default
expression #DX uses (print) to output the result of the
evaluation. Below is a session log illustrating how system variables
can be used to control output formatting of numbers.

alps: (list #FW #PP #EP #SD #OB)   ; list current system variable values
(0 -1 -1 10 10)                    ; these are the default values at start
alps: (i 10)
[1 2 3 4 5 6 7 8 9 10]             ; compact representation
alps: (a #FW 4)                    ; set field width to 4
alps: (i 10)
[   1    2    3    4    5    6    7    8    9   10]
alps: (a #FW -4)                   ; set field width to 4 with padding zeros
alps: (i 10)
[0001 0002 0003 0004 0005 0006 0007 0008 0009 0010]
alps: (* 1e3 (i 10))               ; ? printed where field width too small
[1000 2000 3000 4000 5000 6000 7000 8000 9000 100?]
alps: (a #FW 0)                    ; set field with back to default -> auto
alps: (* 1e3 (i 10))
[1000 2000 3000 4000 5000 6000 7000 8000 9000 10000]
alps: (a #PP 2)                    ; set print precision to 2
alps: (i 10)
[1.00 2.00 3.00 4.00 5.00 6.00 7.00 8.00 9.00 10.00]
alps: (a #PP -2)                   ; force exponent notation
alps: (i 10)
[1e0 2e0 3e0 4e0 5e0 6e0 7e0 8e0 9e0 1e1]
alps: (a #EP 2)                    ; set e notation precision to 2
alps: (i 10)
[1.00e0 2.00e0 3.00e0 4.00e0 5.00e0 6.00e0 7.00e0 8.00e0 9.00e0 1.00e1]
alps: (* 1e3 (i 10))
[1.00e3 2.00e3 3.00e3 4.00e3 5.00e3 6.00e3 7.00e3 8.00e3 9.00e3 1.00e4]
alps: (exp 10 (i 10))
[1.00e1 1.00e2 1.00e3 1.00e4 1.00e5 1.00e6 1.00e7 1.00e8 1.00e9 1.00e10]
alps: (a #PP -1)                   ; set print precision back to auto
alps: (exp 10 (i 10))
[10 100 1000 10000 100000 1000000 10000000 100000000 1000000000 1.00e10]
alps: (a #EP -1)                   ; set e notation precision to auto
alps: (exp 10 (i 10))
[10 100 1000 10000 100000 1000000 10000000 100000000 1000000000 1e10]
alps: (a #SD 5)                    ; set significant digits to 5
alps: (exp 10 (i 10))              
[10 100 1000 10000 1e5 1e6 1e7 1e8 1e9 1e10] ; note switch to e notation
alps: (a #SD -1)                   ; set significant digits to max
alps: (exp 10 (i 10))
[10 100 1000 10000 100000 1000000 10000000 100000000 1000000000 10000000000]
alps: (a #OB 16)                   ; set output base to 16
alps: (exp 10 (i 10))
[0A 64 3E8 2710 186A0 0F4240 989680 5F5E100 3B9ACA00 2540BE400]
alps: (a #OB 10)                   ; set output base back to 10
alps: (a #IB 16)                   ; set intput base to 16
alps: [0A 64 3E8 2710 186A0 0F4240 989680 5F5E100 3B9ACA00 2540BE400]
[10 100 1000 10000 100000 1000000 10000000 100000000 1000000000 1e10]
alps: (a #IB 0A)             ; set input base back to 10,note leading 0 
alps: (list #FW #PP #EP #SD #OB)   ; list current values
(0 -1 -1 10 10)


Printing objects
----------------
print


alps prints string constants using \ to quote the 
three characters " \  and newline (\n) and to quote the
other control characters. For example the expression below
generates a string constant comprised of the first 127 ascii
characters starting at #IO which in this case is 0:

(a #IO 0)
(chr (i 127)) ;=>
"\@\A\B\C\D\E\F\G\H\I\n\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z\[\q\]\^\_
!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"

Note "\"" and "\\" and also the control character exceptions "\n" for
<newline> or <ctrl-J> and "\q" for <ctrl-\>

prin0
princ
prinl princ + \n
pp
plen
tab
lpos

prat

Syntax: (prat <row> <col> [<chr>])

Where: <row> is the row number on the screen to start printing and
       <col> is the column number.
       <row> and <col> must be greater or equal to zero.
       If either <row> or <col> or both are zero the respective position
       remains unchanged.

Function: Prints <> at position <row>,<col> on a vt100 compatible
           screen. <str> is printed raw. This function is primarily intended 
	   to print escape sequences for display control such as bright, blink,
	   etc. Thus line position is not updated. It is assumed that the
	    printing of the optional <str> argument leaves the cursor at the
	    same postion as it was just prior to printing the string. If a 
	    normal string S is to be printed at <row> R and <col> Y then the 
	    the following form can be used: (prat R C) (print S)

Example:

; Print a diagonal line of asterisks going down from left to right
;         from the top of the screen
alps: (let ((CLEAR "\[[H\[[J"))
       (princ CLEAR) (FOR I 1 10 (prat I I "*")) (terpri))
*
 *
  *
   *
    *
     *
      *
       *
        *
         *
t
alps: 

; Print an escape sequence at the current position without affecting the
: line position

alps: (de ESC () (let (B E)
       (princ "\[[H\[[J") ; HOME CLEAR
       (prat 10 10) 
       (a B (lpos))
       (prat 0 0 "\[[7m") (princ "hello") (prat 0 0 "\[[m") ; highlighted
       (a E (lpos))
       (terpri)
       (princl (fmt "start was " B " end was " E))))
=> ESC
alps: (ESC)

  







         hello
"start was 10 end was 15"
alps: 

Outputting linefeeds
--------------------
terpri

Syntax: (terpri [<num>] [<file>])

Function: Outputs linefeeds. If <num> is not specified one linefeed
	   is emitted.  Linefeed are output to the specified <file>.
	   If <file> is not specified linefeeds are output to #PF
	   If <num> is zero a "carriage return" is effected moving the
	   currrent output column back to the beginning with no
	   linefeeds emitted.

Example:

(terpri 3)



=>t
(a MYFILE (open "toto" "w")) ; open file "toto" in write mode
(terpri MYFILE)        =>t
(princ "Hello" MYFILE) => "Hello"
(terpri 4 MYFILE)      => t
(print "done" MYFILE)  => "done"
(close MYFILE)         => t
(du "toto")

Hello



"done"
=> t


Controlling the alps prompt
---------------------------
prompt

Syntax: (prompt)
Type: subr, File I/O
Arguments: none
           #PF current output file
	   #PR current prompt string

Function: Prints the current prompt #PR on the current output file #PF.

Returns: (prompt)

Example:

(let ((#PR "Enter Name: ") N) (prompt) (a N (getl))
     (princ (fmt "Name is " N "\n")) t)
Enter Name: Harry
Name is Harry
t

You can change the alps prompt by setting #PR in the global
environment:

alps: (a #PR "      ")  ;; set prompt to 6 spaces
      (i 10)
[1 2 3 4 5 6 7 8 9 10]
      (clear #PR)       ;; reset prompt to default
APL const 59 reset 
t
alps: 


The beep function
-----------------
beep

Syntax: (beep [<freq>[<duration>]])
Type: sybr, System I/O
Arguments: <freq>:num frequency, integer from 0-63, default 5
           <duration>:num duration, integer from 0-255, default 15

Function: If the sound subsytem in available a beep is played with
          frequency <freq>*81.38Hz for <duration> centiseconds.
	  Otherwise the Bell character "\G" is written the the output
          file.
	  

File handling
-------------


Opening a file
--------------
open

Syntax: (open <fname> [<options>])
Arguments: <fname>:chr 
           <options>:chr
Function: opens the file specified by the fname parameter for use
      by the Input / Output primitives
Returns: file object if successful, nil otherwise

If no options are specified the file is opened in read only mode.
  
 options for a file are: 
   "r"   read only (file must exist)
   "w"   write only, file is created if it does not exist
         file is truncated to 0 length if it does exist
   "rw"  read/write, file is created if it does not exist
   "wa"  write/append, file is created if it does not exist
   "rwa" read/write/append, file is created if it does not exist
Example:
(setq FO (open "myfile" "w")) => #<fob:myfile>


Closing an open file
--------------------
close

Syntax: (close <file object>)
Operations: closes the file associated with file object specified in
the argument
Returns: t   if operation was successful
         nil if file object is already closed
Note: The file object is garbage collected when it is no longer
      referenced. When this occurs it is automatically closed if open.


Buffer handling
---------------

At times it is convenient to operate on internal character data using
the lisp IO primitives such as (read) and (print)

buf

Syntax: (buf <chr> [<buffer-object>])

Function: If only the first argument is given it allocates an internal
          buffer structure for use in Input / Output primitives. The
          initial contents of the buffer are the characters of the
          <chr> parameter. To assign other contents use the dyadic
          form of buf. If the optional second parameter is present it
          initialises the contents of the buffer-object with the all
          characters of the <chr> parameter irrespective of its shape.

Returns: Buffer object.

Example:
(setq B (buf "fred")) =>  #fob<buf>
(read B) => fred
(read B) => nil            ;        <----- end of file
(eof B)  ;=> t
(buf B (p [2 3] "(b)")) => #fob<buf>  ; initialise buf B with "(b)"'s
(read B)                => (b)
(read B)                => (b)
(read B)                => nil                 ; <----- end of file

(a C "Hello Polly")
(a B (buf C))
(read B)   ;=> Hello
(read B)   ;=> Polly
(read B)   ;=> nil
(rewind B) ;=> t
(read B)   ;=> Hello
(read B)   ;=> Polly
(rewind B) ;=> t
C               ;=> "Hello Polly"
(print (i 4) B) ;=> [1 2 3 4]              ; print into buffer  B
C               ;=> "[1 2 3 4]\ny"         ; contents of C modified
(read B) ;=> [1 2 3 4]
(read B) ;=> y
(read B) ;=> nil

Checking for end-of-file
------------------------
eof

Syntax: (eof file)
Arguments: file:file
Type:   subr,file-handling
Function: Test whether end of the file has been seen.
Returns: =>t if current position in <file> is at the end of the file
         otherwise =>nil

Example
-------
(a B (buf "ABC")) ;; B is a file like object.
(getc B) ;=> "A"
(getc B) ;=> "B"
(getc B) ;=> "C"
(eof B)  ;=> t
(getc B) ;=> nil
(eof B)  ;=> t

Memory Management
-----------------


Reclaiming unused space
-----------------------
gc

Syntax:    (gc)
Type:      fsubr, memory management
Arguments: none
Funtion:   Invoke the garbage collector to reclaim unused memory
Returns:   =>t

Note: Garbage collection is invoked automatically whenever
      the available memory is insufficient for a given operation.
      (gc) can be useful when testing to ensure that the program
      starts off with the maximum amount of free memory or to see
      how much actual free memory is available with (pf).


Task handling functions
-----------------------

Discussion:

The system provides a simple "parallel" execution paradigm with
multitasking also known as timesharing. It uses a task control block
to represent the tasks in the system. These are subject to garbage
collection just like any other objects. When it starts up two system
tasks are created: one to run the default expression #DX and the other
to handle asynchronous callbacks. Although the interpreter itself is
single threaded it multiplexes tasks. To create a task one uses the
parallel evaluation primitive (peval Expression [Environment]) which
creates a task to evaluate Expression in Environment. Tasks are run
based on their priority. The system always runs the highest priority
task. Each task is assigned a priority from 0 to 15 where 0 is the
highest priority and 15 is the lowest.  When creating a task with
(peval) it is automatically assigned the default task priority 13. The
priority can be changed with (setpri).  You can see the list of tasks
and their priorities with (wh). Tasks 0 and 1 are the system tasks and
their priority cannot be changed. Task 0, which runs the default
expression, runs at priority 10. Task 1 runs with priority 4. Caution
should be taken not to starve the system tasks.

 Each task also has a state assigned to it. The various states are as
 follows:

done:     task has completed all work
Running:  only one task can be in this state at any given time
runnable: task is ready to run
swait:    waiting on a timer, task or file
winp:     waiting on input
bench:    deferred runnable state when dispatcher is frozen

Tasks are reclaimed by the garbage collector when they are in the done
state and they are no longer referenced. When a higher priority task
is waiting or deferred lower priority runnable tasks are
executed. Tasks with a priority higher than 5 are not pre-emptible and
will run to completion if there are no tasks of even higher
priority. Tasks with a priority of 5 and lower are
pre-emptible. Whenever the system clock ticks the current running task
is pre-empted if its priority is 5 or lower. When a task is pre-empted
it is put behind all other runnable tasks of the same priority as
itself. If there are no tasks of equal or higher priority the
pre-empted task is resumed otherwise the first task of the same or
higher priority is run.

To illustrate this behaviour we define two functions: T and Runem.
(defun T (N)
       (FOR I 1 N
       	    (print (list 'T I))
	    (if (zerop (| 5 I))      ; every 5th iteration
	        (print (wait .5))))) ; wait half a second

(defun Runem (N)
       (setpri 9 (peval `(T N)))     ; Run T with priority 9
       (FOR I 1 N
       	    (print (list 'Runem I))  ; print 
	    (wait .1)))              ; every 10th of a second

Invoking Runem:
alps: (Runem 10)      ; Runem runs in the system task
; Here we see that execution immediately switches to T after (setpri).
(T 1)        ;T prints its first 5 iterations and waits for half a second.
(T 2)
(T 3)
(T 4)
(T 5)
(Runem 1)   ; at which stage runem prints its iterations
(Runem 2)   ; one every 10th of a second
(Runem 3)
(Runem 4)
(Runem 5)
2.629995346e-3   ; T's (wait) completes
(T 6)            ; and it prints the last 5 iterations and waits again
(T 7)
(T 8)
(T 9)
(T 10)
(Runem 6)        ; Runem runs again
(Runem 7)
(Runem 8)
(Runem 9)
(Runem 10)
9.171962738e-3  ; T's (wait) completes again and T finishes
11              ; Runem finishes
alps: 

To illustrate timesharing between two tasks of the same priority

(defun Burn (N P)
       (FOR I 1 N
       	    (if (zerop (| 1e4 I)) (print (list P I)))))

(defun Runem2 (N) (peval `(Burn N 'task1)) (peval `(Burn N 'task2)))
alps: (Runem2 1e5)
#<tcb:5>
alps: (task1 10000)        ; prompt appears because Runem2 has finished
(task2 10000)
(task1 20000)
(task2 20000)
(task1 30000)
(task2 30000)
(task1 40000)
(task2 40000)
(task1 50000)
(task2 50000)
(task1 60000)
(task2 60000)
(task1 70000)
(task2 70000)
(task1 80000)
(task2 80000)
(task1 90000)
(task2 90000)
(task1 100000)
(task2 100000)

Notice how task1 and task2 alternate automatically. 
Garbage collection of the tasks which were run above is shown below:

alps: (wh)  ; list tasks
State    Tid Pri  EnvDepth  StkDepth EvalDepth RunningTime pc
Running    0  10         1         7         0   0:00:00.2 wh
done       1   4         0         1         0   0:00:03.0 done
done       2   9         2         1         0   0:00:00.0 done
done       3  13         2         1         0   0:00:00.0 done
done       4  13         2         1         0   0:00:00.0 done
done       5  13         2         1         0   0:00:00.2 done
done       6  13         2         1         0   0:00:00.2 done
Elapsed:    0:09:45.9 Idle:    0:09:42.3 Busy:   0:00:03.7 Diff:  0.0
Tasks: 7
7
alps: (gc)  ; run the garbage collector
t
alps: (wh) ; show tasks again
State    Tid Pri  EnvDepth  StkDepth EvalDepth RunningTime pc
Running    0  10         1         7         0   0:00:00.2 wh
done       1   4         0         1         0   0:00:03.0 done
Elapsed:    0:14:11.3 Idle:    0:14:07.6 Busy:   0:00:03.7 Diff:  0.0
Tasks: 2
2
alps: 


Paralell Evaluation
-------------------

peval

Syntax:    (peval <expression> [<environment>])
Type:      subr
Function: A separate task is created to evaluate <expression>.
	   The evaluation if the <expression> proceeds in parallel
	    with the execution of the invoking task. If no
	    <environment> argument is passed the task inherits the
	    current binding environment of the invoking task. In other
	    words all bindings visible to the invoking task will be
	    visible to the created task for the duration of the
	    created task even if the invoking task exits before then.
	    Special care must be taken to ensure that there are no
	    race conditions on variables shared in the passed or
	    inherited environment. An argumenent of nil in the
	    <environment> no environment is inherited. Environments
	    captured in functional values can be used here also.

Returns:   Task object identifying the newly created task.
           A task object is opaque and prints as <#tcb:NN> where
	   NN is the task number in the system. This object can be 
	   used as an element in the wait list of the wait function
	   described below.

Example:

alps: (peval '(let ((R 0)) (FOR I 1 1000 (FOR J 1 1000 (incr R))) R))
#<tcb:5>
alps: (wait -1 (list #RS))
(#<tcb:5> . 1000000)
alps: 

Waiting for tasks to complete
-----------------------------

wait

Syntax:      (wait <timeval> [[<tasklist>] [<filelist>]])
Type:        subr
Arguments:  <timeval> 
	    Value: numeric scalar representing the number of seconds
	    to wait.
	    
            <tasklist> optional
            Value: List of tasks that are to be waited for.

	    <filelist> optional
            Value: List of file objects that are to be waited for.

Function:  The invoking task waits, that is suspended depending on the
            parameters passed. 

Returns:    If <tasklist> and <filelist> are nil or not present the
            behaviour is determined solely by <timeval>:
	    If <timeval> is negative the value nil is returned
            immediately.
	    If <timeval> is zero the value zero is returned
            immediately
	    If <timeval> is positive the invoking task is suspended
            for <timeval> seconds. When the time has elapsed the
            function returns the time difference between the expected
            time of completion of the wait and the actual time of completion.

            If <tasklist> or <filelist> are not nil the behaviour is
            determined by the combination of the three arguments: If
            <timeval> is negative then the invoking task is suspended
            indefinitely until either one of the tasks in <tasklist>
            completes or a file becomes ready for reading. Task
            completion has priority over file readiness. If there is a
            compleded task the function then returns the cons of the
            task object and the final result returned by the
            evaluation of the expression passed to the task at its
            creation. If there is a file in <filelist> that is ready
	    the function return a singleton list containing a
            reference to the ready file.

	    If <timeval> is zero the invoking function is not
            suspended but returns immediately. If no task in
            <tasklist> has completed and there is no ready file at
            time of invocation nil is returned otherwise the cons of
            the task object of the first task in <tasklist> to have
            completed and its final result is returned or a singleton
            list of the ready file is returned.  If <timeval> is
            postive and there is a task in <tasklist> that has
            completed the function returns immediately returning the
            cons of the task object in question with its result. If
            there is a file in <filelist> that is ready the function
            return a singleton list containing a reference to the
            ready file. Otherwise the function suspends the invoking
            task until either the <timeval> wait expires or a task in
            the <tasklist> completes or a file in <filelist> becomes
            ready, whichever occurs first. If <timeval> expires the
            return value is numeric or else it will be the cons of the
            task object that has completed with its result or the
            singleton list of the ready file whichever is the case.


Getting the priority of a task
------------------------------
getpri

Syntax:    (getpri Task)
Type:      subr, task control
Arguments: Task to obtain priority of

Returns:   Numeric priority value

Example:
(setq T (peval "hello world"))   ;=> #<tcb:2>
(getpri T)                    ;=> 13


Setting the priority of a task
------------------------------
setpri

Syntax:    (setpri Priority Task)
Type:      subr, task control
Arguments: Task to set priority of
           Priority

Function: Sets the priority of Task to Priority. If Priority is higher
           (i.e. has a lower numeric value) than the priority of the
           task invoking (setpri) Task is immediately run if it is
           runnable and the interpeter has the preemption capability
           enabled.  The second parameter Task is returned in order to
           use the sequence (setpri (peval xxx) Priority) in functions
           such as (wait)
	
Returns:   Task

Example:
(setq T (setpri 10 (peval "hello world")))   ;=> #<tcb:3>
(getpri T)                    ;=> 10
(cdr (wait -1 (list (setpri 10 (peval "hello world"))))) ;=> "hello world"

Sending work to a task
----------------------
send

Syntax:     (send Expression Task [Environment])
Type:       subr, task control
Arguments:  Expression 
	    The form for the task to evaluate
	    Task
	    Destination task for the form
	    Environment
	    Binding environment to use to evaluate Expression

Function:  The form is queued for execution on the task. If the task
	    is idle it is scheduled immediately to evaluate the form.
	    If it is required to synchronise the results with the
	    evaluated forms precautions must be met such that an
	    indication of the request is contained in the result.

Returns:    The function returns the Expression passed.

Example:

(defun TQQ (N) 
 (prog ((T (peval '(TQ 0)))) 
    (FOR I 1 N (send `(list ,I (TIME  (TQ ,I))) T))
    (FOR I 1 (+ N 1) (print (wait -1 (list T)))) 'done))


Atomic execution
----------------
freeze

Syntax:    (freeze)
Type:      fsubr, task control

Function: Locks the dispatcher preventing any other task from
	   executing until (thaw) is invoked. Calls do not nest.

Example:
We define two functions that compete: F and G

(defun G () (peval '(F)) (FOR I 1 50 (print (list I (clock))) (wait 0.1)))
(defun F () (FOR I 1 10 (freeze) (wait 1) (thaw) (wait 0)))

When we invoke (G) it schedules a task to evaluate (F) which locks out
G ten times for one second in succession. The last (wait 0) in F is
the equivalent of a yield so that it lets (G) run before invoking
(freeze) again. The result is the G prints the first 10 numbers at 1
per second followed by the rest at an interval of 1 tenth of a second
each.


Interrupting a task
-------------------
kill

Syntax:      (kill tid | tcb)
Type:        subr, task control
Arguments:   tid  numeric task id
             tcb  task obkect returned by (peval)
Funtion:     Interrupts the task referred to by tid or tcb
Return:      t if the task was found
             nil if the task was not found

Interpreter control functions
-----------------------------

Exiting the system
------------------

quit

Syntax:    (quit [<exit status>])
Type:      subr, sysctl
Function: Immediately terminates the program without saving the
	   workspace. The optional numeric <exit status> parameter,
	   which should have a value between 2 and 255 inclusive, is
	   used as the exit status of the program. If not supplied an
	   exit status of 0 is used. Exit code 1 is reserved for
	   abnormal end by the system.
	   
Example: 
alps: (quit 4)

alps aborted per user request
bash$ echo $?
4
bash$ 


bye

Syntax:    (bye)
Type:      fsubr, sysctl
Function: Tell the system to shut down when it returns to the default
	   expression or Read-Evaluate-Print loop from the main
	   expression that invoked (bye). The workspace is saved in
	   the current working directory and the system exits. The
	   default file name for the saved workspace is "APLSAV".

Example: Terminating with (bye) and restarting from saved workspace
alps: (bye)
t

alps terminating per user request
Workspace saved in APLSAV from 0x36000000 size = 64MB
bash$ 
... some time later ...
bash$ alps
alps Linux 32bit Interpreter V6.73
Workspace restored from APLSAV
  last saved: Thu Jan  5 08:34:12 2012

alps: 


Saving the workspace
-------------------
save

Syntax:      (save [<workspace-name>])
Type:        subr, sysctl
Arguments:   <workspace-name>:chr optional
             If the argument is not present the default workspace-name
	     "APLSAV" is used.
Function:    The current workspace is saved to the file
             specified by <workspace-name>.


Restoring a workspace
---------------------
restore

Syntax:      (restore [<workspace-name>])
Type:        subr, sysctl
Arguments:   <workspace-name>:chr optional
             If the argument is not present the default workspace-name
	     "APLSAV" is used.
Function:    The saved workspace is restored from the file
             specified by <workspace-name>. The contents of the
	     previously current workspace are lost.


Evaluating a lisp expression in a character array
-------------------------------------------------
exec

Syntax:     (exec <expression>)
Type:       subr, evaluation
Arguments:  <expression>:chr array
Function:  The characters in <expression> are read by the reader and when
            the first s-expression has been read it is evaluated and
	    the result returned. All further characters are silently ignored.
Example:

(exec "(i 10) nil") ;=> [1 2 3 4 5 6 7 8 9 10]


Evaluating lisp expressions from a file
---------------------------------------

load

Syntax: (load <filename>)

Type: subr

Function: The lisp expressions contained in the file referred to by
          <filename> are evaluated. Results of the evaluated
          expressions are not printed unless the interpreter is in
          debug mode. If the <filename> is a fully qualified path,
          i.e. starting with a slash "/" or a tilde "~" or a dot "."
          then filename as given is used. On the other hand if the
          path is not fully qualified then the file is searched for in
          the following manner.  If the load path variable #LP is nil
          the current working directory is searched else each
          directory in the list #LP is searched in order. Furthermore
          if the last part of <filename> does not contain a dot the
          suffix ".al" is appended to <filename> when searching. If
          the file is found and is readable the expressions contained
          in it are evaluated. If no untrapped errors occur the
          <filename> with any appended suffix is prepended onto the
          list of the load history file #LH. This variable is used by
          the conditional load function (require <filename>) to check
          whether the file has already been loaded.

Example:

alps: #LH
(".alps"  "qt.al"  "cl.al"  "dll.al"  "prims.al")
alps: (load 'qq)
loading qq.al
t
alps: #LH
("qq.al"  ".alps"  "qt.al"  "cl.al"  "dll.al"  "prims.al")
alps: (load "~/alps/lisp/tqq")
Trapped out back to main
File/Directory not found: open file
encountered at step load
(load "~/alps/lisp/tqq")
alps: (load "~/alps/lisp/tqq.al")
loading ~/alps/lisp/tqq.al
t
alps: #LH
("~/alps/lisp/tqq.al"  ".alps"  "qt.al"  "cl.al"  "dll.al"  "prims.al")
alps: (load "fib.al")
loading fib.al
t
alps: #LH
("fib.al"  "~/alps/lisp/tqq.al"  ".alps"  "qt.al"  "cl.al"  "dll.al" 
"prims.al")
alps:

	   
Conditional loading of a file
-----------------------------

require

Syntax: (require <feature> [<filename>])

Function: If the <feature> has not been loaded, i.e. it is not a
           member of the list in #LH the feature is loaded from the
           file named "<feature>.al" by looking for it in the
           directories in the list in #LP. If the optional <filename> is
	   provided it will load that file instead. See (load) for how
	   <filename> is handled.

Returns: <feature> if the feature was already loaded
         t if the feature had to be loaded
	 
Example:
#LP ;=> ("." "~/alps/lisp" "~/alps/local/")
#LH ;=> (".alps" "prims.al")
(require 'idioms) ;=> t
loading idioms.al
#LH ;=> ("idioms.al" ".alps" "prims.al")
(require 'idioms) ;=> idioms
#LH
("idioms.al" ".alps" "prims.al")


Dumping a file to the output stream
-----------------------------------
dump

(dump <file>)

Compiler Specials
-----------------
addr
mint
mkprc
rdda
mget
mput
sysp
arg

Time related primitives
-----------------------

Pausing execution
-----------------

wait

Syntax:    (wait <timeval>:s)
	   For the more general form of invocation see wait in task handling.
Type:      subr
Argument:  <timeval> numeric scalar representing the number of seconds
           to wait.
Function: Execution is paused for the time interval specified by
           <timeval>.
Returns:   If <timeval> is zero or positive the funtion returns the 
 	   difference between the expected time and the actual time of
	   continuation of execution in seconds 
	   Otherwise nil is returned.


Obtaining CPU times used
------------------------
time

Syntax: (time)
Type:   fsubr

Function: Creates a vector of CPU time used in seconds starting
           the count from the most recent launch of the interpreter.

Returns: Numeric vector. (p (time)) => 5

         The first element is a high resolution measure of the CPU
         time used by the interpreter process.
        
         The second element is the user CPU time used by the
         interpreter process.

         The third element is the system CPU time used by the
         interpreter process.

	 The fourth element is the user time used by any children
	 processes.  

	 The fifth element is the system CPU time used by any children
	 processes.  


Example: 
(time) ;=> [.057638281 .015997 .040993 0 0]

;We can use (time) to measure the CPU time used to evaluate a form as
;follows:

alps: (a T1 (time))                                 ; take CPU time stamp
alps:  (FOR I 1 1e5 (m/ (p [10 10] (? 100 100)))) ; evaluate form
       ; invert 1e5 10x10 matrices
100001
alps: (- (time) T1)                                 ; get CPU time difference
[3.874248631 4.024252 0 0 0]     
; result is that the computation used approximately 3.9 seconds of CPU time

A function to measure the execution time of an evaluated expression could be
defined as follows:

alps: (defexpr TT (X) (let ((T1 (time))) (print (eval (car X))) (- (time) T1)))
alps: (TT (FOR I 1 100000 (m/  (p [10 10] (? 100 100)))))
100001
[3.906475824 3.928246 0 0 0]


Note: CPU times used are not preserved across sessions

Measuring elapsed time
clock 

Syntax: (clock)

Function: Creates a numeric scalar representing the elapsed time
           in seconds starting from some arbitrary point in the past.

Returns: Numeric scalar time value

Example:

alps: (clock)
1270053838
; Define a function to measure the elpased time taken to evaluate an expression
alps: (defexpr ETIME (X)
 (let ((T1 (clock))) (print (apply 'eval X)) (- (clock) T1)))
ETIME
alps: (ETIME (read))
"this is a string" 
"this is a string"
2.207962036 ; this is how long it took the user to type in the string


Obtaining the date and time
date 

Syntax: (date [time])

Function: Formats the time argument into Seconds, Minutes, Hours, Day
           of Month, Month of year and year. The Daylight savings
           offset in hours and the seconds east of the current
           timezone are appended. If no argument is given the current
           time as returned by (clock) is used. Dates relative to the
           current time can be obtained by supplying an argument
           computed from (clock) + relative offset in seconds.

Returns: Numeric vector where the successive elements represent:
	1  Seconds       range:     [0-60]       
	2  Minutes       range:     [0-59]  
	3  Hours         range:     [0-23]  
	4  Day of month  range:     [1-31]  	   
	5  Month of year range:     [0-11]  
	6  Year - 1900   range:     [0-n]          
	7  Day of week   range:     [0-6]   
        8  Day in year   range:     [0-365] 
	9  Daylight Saving offset   [-1/0/1]
	10 Seconds east of UTC.     [0-82800]

Note: The range of the values in the vector are independent of the
      index origin. Some systems do not give the tenth element.

Example:

alps: (date)
[26 53 18 31 2 110 3 89 1 7200]
alps: (defun FD (D) ; function to format date nicely into YYYY/MM/DD HH:MM:SS
(fmt (+ (aref D 6) 1900) "/" (+ 1 (aref D 5)):-2 "/" (aref D 4):-2
      " " (aref D 3):-2 ":" (aref D 2):-2 ":" (aref D 1):-2))
FD
alps: (FD (date)) ; format current date assuming #IO => 1
"2010/03/31 20:00:18"
alps: (FD (date (- (clock) (* 3600 9)))) ; format date 9 hours back
"2010/03/31 11:00:20"

stats => advanced section

Graphics
--------
These functions are available when the graphics subsystem is enabled: 
(HASCAPS "G") ;=> t

Initialise graphics library
---------------------------
glinit

Syntax: (glinit)
Type: subr, Graphics
Arguments: #CC clear colour
Function: Initialises the graphics library for the current canvas

Note: must be called after (dispwdgt aCanvas)

Set projection mode
-------------------
proj

Syntax: (proj <mode>)must be called after setting
Type: subr, Graphics
Arguments: <mode>: t | nil
           #WN Window
	   #NF Near and Far planes
	   #OP Observer Position
	   #OF Observer Focus
	   #VP ViewPort
Function: If (eq <mode>	t) perspective projection mode is set
          If (null <mode>) Ortho projection mode is set
	  In doing so #WN, #NF, #OP, #OF and #VP are taken into
	  account.

Plot points or list of points
-----------------------------
graf

Syntax: (graf [mmode] <arg>)
Type: subr, Graphics
Arguments: mmode: optional 0 | 1 | 2
                  default 0
           <arg>: num array | chr vector | list of (num array | chr
                  vector)
            #PM (plot mode - fill etc),
            #DM (display mode - lines, poly etc)
	    #PN (pen number)
	    #LS (line style)
Function: Assuming (eq #IO 1)
           For each <item> in the list or the single item in <arg>
           If (chr <item>) plot the characters of item at the current
	   position
	   else
	     (rank <item>) must be 1,2 or 3
	     mmode is relevant only if the last dimension has length
	     1.
	     if (zerop mmode) then the  current position is moved to
	            <item>:  (aref <item> () 1)
	     if mmode is 1 a line is drawn from the last point to
	     <item> as an absolute value in the window.
	     if mmode is 2 a line is drawn from the last point to the
	     last point + <item> i.e. relative to the last point.

	     if (onep (rank <item>)) plot <item> values on the Y axis
	     over the whole of the X axis.
	     else (if (eq (rank <item>) 2))
	        plot <item>
		   with (aref <item> 1 ()) as X coords
		   and  (aref <item> 2 ()) as Y coords
		   and  (aref <item> 3 ()) as Z coords
	          (aref <item> 4 ()) is ignored, used for transformations.
	     
Get widget aspect ratio
-----------------------
gwar

Syntax:  (gwar <widget>)
Type: subr, Graphics
Arguments: <widget>:wgt

Returns: the ratio of the width to the height of <widget> 


Select current graphics canvas
------------------------------
gcanvas

Syntax:     (gcanvas <canvas>)
Type:       subr, Graphics
Argument:   <canvas>:wgt 3D graphics canvas to be made the
                     current canvas.
Function:   Makes <canvas> the current canvas for subsequent
            graphics operations.
Returns:    t for success else nil	    


Load image into current canvas
------------------------------
gload

Syntax:     (gload <image-file-name> [<scale> [<image-spec>]])
Type:       subr, Graphics
Arguments:  <image-file-name>:chr name of image file to display
	                      it can be in ppm, gif, tiff or jpeg
			      format depending on the types supported
			      by the graphics package.
	    <scale>:nsgl optional  0, 1 or 2
	            0 no scaling
		    1 scale to whole viewport
		    2 scale to whole viewport maintaining the
		    aspect ration of the image or subimage.
	    <image-spec>:nv optioanl a numeric vector of 2 or 4
	                elements specifying the subimage to load
			elements 0 and 1 are the x and y offsets
			from the top left hand corner in pixels
			elements 2 and 3 are the width and height
			in pixels.
	    #VP viewport
	    The current canvas can be selected using (gcanvas)
Function:   Extracts the image or optionally the subimage from the
	    image file and displays it on the current
            canvas optinally scaling the image according to <scale>
Return:     Returns its second argument

Save canvas to image file
-------------------------
gsave

Syntax:     (gsave <canvas> <image-file-name>)
Type:       subr, Graphics
Arguments:   <canvas>:wgt graphics widget
            <image-file-name>:chr name of file to write the image to.
Function:   Saves the image in <canvas> to a file in ppm
	    format.
Return:     Returns its second argument



loc

	
gupdate must be used when #GB=>t


Operating System commands
-------------------------


System Command
--------------
sys

Syntax: (sys <chr>+)

Function: Calls the operating system shell to execute the command
           which is the concatenation of all the <chr> arguments.


Returns:   t if the call suceeded else nil.

Notes: 
  1. The concatenation does not add any spaces between the supplied
     arguments.

  2. The standard input, output and error files for the shell command are
     the same as those when the interpreter was invoked. In other words
     changing the current print file #PF does not affect the standard output
     for the shell command.

  3. While executing a shell command in the foreground the
     watchdog timer is temporarily disabled.
  
Example:
(sys 'ps) ;=> t
=>
  PID TTY          TIME CMD
 2138 pts/0    00:00:00 bash
 2475 pts/0    00:00:00 alps
 2476 pts/0    00:00:00 sh
 2477 pts/0    00:00:00 ps

(sys "nano lisp/prims.al") ;=> t

Working Directory
-----------------
wd

Syntax: (wd [<new-directory>])


Example:
(wd)       ;=> "/home/dave/alps"
(wd "..")  ;=> "/home/dave/alps"
(wd)       ;=> "/home/dave"

Directory List
--------------
dl

Syntax: (dl [<file-name> | <directory-name>])

If no argument is given the current working directory (wd) is used.

Returns: The value nil is returned if there is no object in the
	 filesystem referred to by the argument.  If the argument is
	 the name of a file the argument is returned.  If the argument
	 refers to a directory the list of names of the files in the
	 directory is returned.

Examples:
;
; No argument provided
;
alps: (wd)
"/home/dave/alps"
alps: (dl)
(".alps_history"  "LX"  "data"  ".."  "HISTORY"  "README"  "lisp"  ".alps" 
"doc"  "alps"  ".")
;
; Directory argument
;
alps: (dl "data")
("p1"  "piorb"  "p3"  "csc"  "quasar"  "p6"  "tet"  "p7"  "p2"  "p5"  "thing"
 "pa"  ".."  "p10"  "hvst"  "p8"  "gldr"  "p4"  "p9"  "."  "patterns"  "math")
alps: (sort (dl "data") 'lt)  ; Sorting the list using the less than operator
("."  ".."  "csc"  "gldr"  "hvst"  "math"  "p1"  "p10"  "p2"  "p3"  "p4"  "p5"
 "p6"  "p7"  "p8"  "p9"  "pa"  "patterns"  "piorb"  "quasar"  "tet"  "thing")
;
; File argument
;
(dl "README") ;=> "README"
;; The following function can be used to determine whether a file exists
(defun isFile(F) (eq F (dl F)) ;=> isFile
(isFile "README") ;=> t                             
;
; Non-existant file argument
;
(dl "COBOL")      ;=> nil
(isFile "COBOL")  ;=> nil

Get environment variable
------------------------
getenv

Syntax: (getenv <environment-variable>)
Where:  <environment-variable> is a character vector
Return: nil if the environment variable is not set
        else character vector with contents of <environment-variable>
Limitation: Both the <environment-variable> and its value must each
            not be longer than 512 octets.

Example:

$ export FRED=fish
$ ./alps -f /dev/null   # ignore .alps startup file
./alps Linux 64bit Interpreter V7.39 cpt 100
loading /dev/null
alps: (getenv "FRED")  ; a previously defined environment variable
"fish"
alps: (getenv "POLLY") ; an undefined environment variable
nil
alps: (getenv "HOME")  ; get home directory from un*x environment
"/home/user1"

Set environment variable
------------------------
setenv

Syntax: (setenv <environment-variable> <value>)
Where:  <environment-variable> and <value> are character vectors
Return: nil if the environment variable is not set else t
Limitation: Both the <environment-variable> and <value> must each
            not be longer than 512 octets.

Example:
(setenv "POLLY" "put the kettle on") ;=> t
(sys "echo $POLLY") ;=> t
put the kettle on
(getenv "POLLY") ;=> "put the kettle on"

Purge file 
----------
pu

Rename file
-----------
rn

Example:
(rn "SIN.al" "sin.al") ;=> "sin.al"

File Status
-----------
st

Syntax: (st <file-name>
Function: Obtains the file status from the filesystem and returns
	   the attributes in a list.

Returns:  If the object referred to by the argument does not exist
          nil is returned. 
	  Otherwise the elements of the list have the following interpretation:

0         File type: nil for a directory or the file name (i.e. argument) 
          for a file.

1	  The size of the file in octets

2	  The user ID of the file as a string if possible otherwise as number

3         The group ID of the file as a string if possible otherwise as number

4	  The time of last access (number)

5	  The time of last modification (number)

6	  The time of last status change (number)

7	  The file modes and access rights (0 <= number <=4095)

8         The file type code (0 < number < 12)
	  For Linux
           1 = FIFO
           2 = character device
	   6 = block device
           8 = regular file
          10 = symbolic link
          12 = socket

9         The number of hard links

Example:
Produce 'ls -l' style output.



(defun dirp (N) ((lambda (X) (and (consp X) (null (car X)))) (st N)))

(defun filep (N) ((lambda (X) (and (consp X) (eq (car X) N))) (st N)))

(remove-if dirp (dl))




Interpreter Utility Funcions
----------------------------


Print version
-------------
pv

Syntax:    (pv)
Type:      fsubr, system
Arguments: none
Function:  Prints detailed version information
Returns:   t
Example:
(pv) => t
Sourcefile alps.c Time-stamp: <2014-02-26 21:42:33 dave>
gccVersion 4.8.2
gccFlags   -g -m64 -std=gnu99 -Wall -Wno-unused 
gccHost    Linux slacky 3.13.1dmp #1 SMP PREEMPT Thu Jan 30 18:41:52 CET 2014
gccProc    x86_64 Intel(R) Core(TM) i7-3720QM CPU @ 2.60GHz GenuineIntel
Executable src/alps Linux 64bit Interpreter V7.18 cpt 100


Print Free memory table
-----------------------
pf

Syntax:    (pf [1 | 2 ])
Type:      subr, system
Arguments: optional scalar
Function:  Prints information about free and allocated memory in the
           workspace. The optional argument increases the details
           shown but are only relevant for system debug.
Example:
(pf) => t

Memory allocation Summary Total Workspace size: 128MB

Type        Free       Busy      Total      Diff     Nfree     NBusy GCcnt
WS:     82229648   51987976  134217624         0        92      3834
ATM:                 339808     339808                          3818     0
FS:     33261408     293024   33554432         0   2078838     18314     0
Env:    16777008        208   16777216         0         3         5     0
Stk:           0    1048640    1048640         0         0         2     0
Cnt:           0        160        160         0         0         2     0
Tcb:           0        512        512         0         0         2     0
Fob:           0       3616       3616         0         0         4     0

File allocation Summary
FINP   1; FOUT   2; FIO   0; FPASS   0; FCLOS   1; 

Legend: 
WS:  Workspace overall
ATM: Symbols, scalars, and character, numeric and reference arrays
FS:  Cons cells
Env: Binding environments
Stk: Evaluation stacks
Cnt: Continuations
Tcb: Task control blocks
Fob: Foreign objects such as files, buffers, widgets etc.

Free:  Available memory in octets
Busy:  Occupied memory in octets
Total: Total size of memory allocated for the resource type
Diff:  Total - (Free + Busy)
Nfree: The number of free entities (cache pool)
NBusy: The number of busy entities  
GCcnt: Shows the number of garbage collections that were triggered due
       to a penury occuring when trying to allocate memory for the 
       corresponding resource type.
FINP:  Files open for input
FOUT:  Files open for output
FIO:   Files open for input/output
FPASS: Passive sockets
FCLOS: Number allocated closed files.

Print Task Table
----------------
wh

Syntax:    (wh)
Type:      fsubr, system
Arguments: none
Function:  Shows what's that that is going on from a task perspective
Returns:   Number of tasks in table.

Example:
(wh) ;=> 9
State    Tid Pri  EnvDepth  StkDepth EvalDepth RunningTime pc
Running    0 255         1        22         4   0:00:00.0 wh
done      19 255         6         1         0   0:00:00.0 done
done       1  10         0         1         0   0:00:00.0 done
runable   16 255        11       124        18   0:00:00.8 ckargs
runable   21 255        11        53         9   0:00:00.7 incr
runable   20 255        11        65        10   0:00:00.6 evargs_do
runable   17 255        11       123        18   0:00:00.6 cons
swait     18 255         5        27         4   0:00:00.0 nop
swait     15 255         3        33         5   0:00:00.0 nop
Elapsed:    0:02:00.7 Idle:    0:01:06.2 Busy:   0:00:54.4 Diff:   0:00:00.0
Tasks: 9

Note: Diff is the difference between elapsed and idle+busy. It
reflects the time that timer interrupts are blocked or the machine is
sleeping. Timer signals are blocked for sound and GPIB instrument
control primitives.


Symbols in the system
---------------------
oblis

Syntax:    (oblis)
Type:      fsubr, system
Arguments: none
Function:  Obtain the lists of symbols in the system
Returns:   List of list of symbols in alphabetical order


Execution statistics
--------------------
stats

Mostly relevant for developers.
Syntax:    (stats [nil | t])
Type:       fsubr, system
Arguments:  optional flag t | nil
Function:   To start statistics collection specify the optional
	    argument as t. To stop collects pass nil. Without argument
	    collected statistics are returned. Statistics collection
	    samples the interpreter code executed.
Returns:    With no argument returns a list for each interpreter
	    function code with (name call_count event_count) where
	    name is the name of the interpreter function code,
	    call_count is the number of timer the function code was
	    invoked and event_count is the number of time the function
	    code was executing when the sampling timer expired. The
	    latter gives an idea of which function codes used up how
	    much of the execution time.

Examples;
(stats t)   ;=> (stats t)   ;; start statistics collection.
(stats nil) ;=> (stats nil) ;; stop statistics collection.
(stats) :=> ((nop 0 0) (cond 13304 0) (fun 1 0) (de 599 0) (df 23 0)
(dm 19 0) (dc 0 0) (defconst 4 0) (apply 0 0) (eval 16 0) (lambda 0 0)
(label 0 0) (cont 0 0) (fnarg 0 0) ....

A routine (Profile) is provided in prims.al that will profile the
execution of an expression

(Profile (TQ 3)) ;=> "TQ End"
=>
evaldx                 0         0         0         0          0
bootstrap              0         0         0         0          0
exit                   0         0         0         0          0
dbgout                 0         0         0         0          0
cwcc1                 88         0         0         0          0
.....
member              5833       .02     16736      4.67         44
sys_eval         5544375     14.62     21551      6.01         50
sys_apply        6676949      17.6     28055      7.83         58
evargs           4699830     12.39     57947     16.16         74
subset           1853556      4.89     90382     25.21         99
Total instruction count: 37933710; Total time : 3.58499

This shows that most of the time was spent in (subset) and
(member). sys_eval and sys apply are interpreter internal functions.

Column       Description
   1         Function code name
   2         call count
   3         percentage of call count over all calls
   4         event count
   5         percentage of execution time over total execution time
   6         Cumulative execution time percentage


System Variables
----------------

Sort them

 #IB input base                        
 #OB output base                       
 #PP print precision                   
 #PW print width                       
 #FW field width                       
 #SD significant digits                
 #EP e format mantissa digs after point
 #VP view plane                        
 #WN window limits                     
 #NF near far planes                   
 #CS character size                    
 #CR character rotation                
 #PM polygon mode 0-2                  
 #PN pen number                        
 #LS line style                        
 #RL random link                       
 #IO index origin                      
 #CT comparison tolerance
     Default value 1e-13
     Comparisons using #CT:
     Two numbers are considered equal if 
     (| (-  A B)) is less than equal to (* #CT (c (| A) (| B)))
 
 #TR trace depth                       
 #AI additive identity = 0             
 #MI multiplicative identity = 1       
 #MN minimum number =  1.7976931348623e308               
 #MX maximum number = -1.7976931348623e308               
 #NN not a number = Nan            
 #RA result address pointer            
 #DM drawing mode 1 - 12 (see EZ_BEGIN)
 #OP Observer position                 
 #OF Observer focus                    
 #VN Version Number major.minor        
 #PL Print Length                      
 #PD Print Depth                       
 #LL print List Length                 
 #DD Debug print Length                
 #DL Debug print list Length           
 #GC number of garbage collections     
 #FM Free Memory vector                
 #FS Sampling frequency for dsp         
 #GS Gensym base string end with digits
 #CP Capability string                  
 #RF read file object                        
 #PF print file object                        
 #LF log file object                         
 #HF history file name                     
 #RS last result     - free variable in default #DX (see below)
 #EX last expression - free variable in default #DX (see below)                 
 #LX latent expression
     Evaluated when restoring a workspace.
     When no workspace is loaded it is set to nil.
     The effective latent expression when no workspace is found is
     (load ".alps") by default or (load <init-file) if the -f option
     was specified on the command line.
 #DX Default expression
     The default built-in #DX is a prompt-read-eval-print routine:
     (let ()
       (prompt)                                                  ;; prompt
       (a #EX (read)) (rclr)                                     ;; read
       (a #RS (eval #EX))                                        ;; eval
       (cond ((or (nlistp #EX) (ne (car #EX) 'a)) (print #RS)))) ;; print
     The default expression is repeatedly evaluated unless it is
     specified with the -e option in which case it is evaluated only once.
 #WS workspace name - default "APLSAV" in the working directory                 
 #SW t if workspace is to be saved on exit   
 #HS History Stack (most recent first) 
 #PR Default prompt string             
 #LP Load Path
     A list of directories to search when loading files.
     See (load) and (require)
 #LH Load History                      
 #QQ Quasiquote simplify hook          
 #KB KeyBoard translation assoc list   
 #WD Watchdog timer used to trap out of infinite loops.
     Sends an interrupt signal if looping internally for more than #WD seconds.
     Set to zero to disable.
     Automatically disabled during (sys).
     Default value 5 seconds.
#NM  Name of the alps executable (argv[0]). To set the prompt to the
     executable name after the last / (if any):
     (a  #PR {(tk (- 1 (ind (rev #NM) "/")) #NM) ": "})
#AL  List of the non -option arguments from the command line used to
     invoke alps.
     
Initialization
--------------


Usage: 

alps [-D] [-T] [-d] [-f <init-file>] [-e <expr>] [-h <hist-file>] [-s]
[-t <tty>] [-w <dir>] [names...]
alps [-v | -V ]
Options
-D             Enable debug on startup
-T             Enable trace on startup
-d             Run in daemonic mode.
-e <expr>      Set the default expression to <expr>
-f <init-file> Read <init-file> on startup
-h <hist-file> Use commands <hist-file> as history stack
-n             Suppress banner and extraneous output 
-s             make alps process a session leader
-t <tty>       Use <tty> as input/output device
-w <dir>       Change to working directory <dir> immediately on startup
-v             Print version number to stdout and exit, 
               other options are ignored
-V             Print full version info and exit, other options are
               ignored
names...       All the arguments after the -options are placed in a list
               of strings bound to the system variable #AL

When alps starts it first checks for a saved workspace file "APLSAV"
in the current directory. If it finds the file the workspace is
restored and the latent expresssion in the system variable #LX is
evaluated. By default this variable has the value nil. If the
workspace file is not found alps loads and evaluates the expressions
in the init-file. The init-file is specified using the -f option. If
no init-file is specified it looks for the file ".alps" in the current
directory and uses it as the init-file. Note that when a workspace
file is restored no init-file processing takes place. Any
initialisation that needs to occur when the workspace is restored must
be done in the latent expression contained in the #LX variable saved
with the workspace.

Note that -e sets the default expression #DX to its argument. However,
if #DX is alo set in the init-file or other file loaded at startup,
that setting will override the -e argument. This is because alps first
evaluates the latent expression #LX which is (load ".alps") by default
or (load <file>) when the argument -f <file> is given. Only after the
latent expression #LX has been evaluated, does the system proceed to
evaluate the default expression #DX. If the -e option is specified the
resulting default expression is evaluated once and the system then
exits. On the other hand if -e is not specified #DX is repeatedly
evaluated until the end-of-programme condition is set with <ctrl-d> on
the input or evaluating (quit) or (bye).

Line editor and history commands
--------------------------------

When alps is invoked from a terminal the features of the built-in line
reader for line editing and history commands are available. Each line
of text entered is stored in the history stack. The current stack is
bound to the system variable #HS with the most recent entry first. The
system variable #HF is bound to the file name of the current history
file. By default it is .alps_history in the current directory where
alps was started. See Initialisation for providing a custom history
file with the -h option. When alps terminates it overwrites history
file with the current history stack.

This section describes the actions of the line reader associated with
each input character.

<ctrl-Space> Sets the current MARK at the cursor position

<ctrl-a> Moves the cursor to the beginning of the line
         If the cursor is already at the beginning of the line
         brackets are placed around the line and the cursor is
         positioned after the opening bracket at the beginning of the
         line.

<ctrl-b> Moves the cursor backwards one character in the line.

<ctrl-c> Not an editor command. Sends an interrupt and resets the line
         reader if waiting for input.

<ctrl-d> At the beginning of a line sends an end-of-file condition
	 which will normally terminate the programme.
	 Deletes the character on the cursor.
	 Ignored at the end of the line.

<ctrl-e> Moves the cursor to the end of the line.

<ctrl-f> Moves the cursor forward one character.

<ctrl-g> Illegal character

<ctrl-h> or
<Backspace> Deletes the character preceding the cursor.

<ctrl-i> or
<Tab>	 Autocompletion. If the word is a symbol the completions are
         looked up in (oblis). It the word is a character vector
         (starts with ") the completions are looked up in the list of
         filenames/directories in the current directory. Otherwise it
         does nothing. Completion candidates are those that match the
         initial characters from the start of the word up to the
         character preceding the cursor. If there is only one match the
         remaining characters are inserted automatically. If there are
         more than one match nothing happens until <ctrl-i> or <Tab>
         is pressed again in which case the list of candidates is
         printed on the terminal.
	 
<ctrl-j> or
<Enter> Signals the end of line input.

<ctrl-k> Deletes the contents of the line starting from the cursor to
         the end of the line. Deleted characters are placed in the
	 yank buffer.

<ctrl-l> Refreshes the line

<ctrl-m> Signals the end of line input.

<ctrl-n> Displays the next line in the history stack going forwards in
         history.

<ctrl-o> Illegal character

<ctrl-p> Displays the previous line in the history stack going
         backwards in history.

<ctrl-q> Escape character for entering a control character.
         For example to insert <ctrl-d> in a string
         "abc<ctrl-q><ctrl-d>"
	 This is equivalent to typing "abc\D"

<ctrl-r> Search backwards in history for the character sequence
	 entered after the <ctrl-r>. The first matching line is
	 automatically displayed and can be edited by moving the
	 cursor or entered by hitting <Enter> Repeating <ctrl-r>
	 searches for the previous (earlier) occurrence of the
	 character sequence backwards up the stack.

<ctrl-s> Search forwards in history for the characters entered after
	 the <ctrl-s>. The first matching line is automatically
	 displayed and can be edited by moving the cursor or entered
	 by hitting <Enter> Repeating <ctrl-s> searches for the next
	 (more recent) occurrence of the character sequence forwards
	 down the the stack.

<ctrl-t> Transposes the character on the cursor with the one preceding
         it.

<ctrl-u> Deletes the characters from the beginning of the line to but
         not including the character on the cursor. Deleted characters
         are placed in the yank buffer.

<ctrl-v> Inserts the previous line from history at point

<ctrl-w> Deletes the characters from MARK up to but not including the
         character on the cursor. Deleted characters are placed in the
	 yank buffer.

<ctrl-x> Keycode replacement. Inserts the text associated with the
         following character entered in the list bound to #KB.

<ctrl-y> Inserts (pastes) the text from the yank buffer after the
 	 cursor. See <alt-w>

<ctrl-z> Handled by terminal - normally puts alps into the background
         and gives the shell prompt. alps can be brought back to the
         foreground with the fg shell command.

<alt-backspace> Deletes characters from cursor up to and including the
		beginning of the word.

<alt-b> Moves backwards one word.

<alt-d> Deletes the charcaters from the cursor to the end of the word.

<alt-f> Moves forwards one word.

<alt-t> Transpose word on cursor with previous word.

<alt-w> Saves (copies) the text between MARK and the cursor into the
	yank buffer.

<ctrl-alt-b> Moves back one bracket

<ctrl-alt-f> Moves forward one bracket


Debugging
---------

When it is required to debug code you can set the debug mode of the
interpreter with the (dbg) command. In this mode the interpreter
generates more state information on the execution stack to facilitate
debugging.

dbg

Syntax: (dbg <expr>)
Type:   fsubr,debug
Arguments: <expr>:sexpr.
Function:  <expr> is evaluated with debug enabled.


Returns:   The result of evaluating <expr> is returned.

When debug mode is enabled the break interaction mode is invoked
whenever an error or user interrupt occurs. The break mode can also be
invoked programmatically with (break).

At the prompt in break mode any expression is evaluated as normal
in the binding context where the error occured or where the (break)
was executed. Thus any visible bound variables may be examined or
modified as required. The break processor additionally recognises the
following commands:

]<RET> In debug mode displays the current binding environment

)<RET> In debug mode shows the current execution stack

.<RET>  In debug mode this can be used to "single step" execution. The
        interpreter  will continue the evaluation of the current expression
        re-invoking the break processor when the next sub-expression is
        evaluated.

        When not in debug mode it just continues

-<RET> Behaves like .<RET> but additionally prints the result of the
       stepped expressions.

[0-9]* Moves the stack and corresponding binding context of the break
processor up or down the stack to the corresponding nesting level.

[]<RET> Entering symbol for the null vector returns debug nesting back
	to the top level.

nil<RET> | ()<RET> | <EOT> continues

Break function
--------------
break

Syntax: (break <expr>*)
Function: Used for debugging. 
Returns: nil

When the form (break <expr>*) is evaluated the cdr of the form is
printed, the break prompt is issued and break mode is entered.

Example:
alps: (defun M (X) (cond ((gt X 10) (break MyFun) (list X 'done)) (t 'exit)))
M
alps: (a X 0)
alps: (dbg (M 32))
(MyFun)
break: X            ; show value of X
32
break: (a X 42)     ; set value of X to 42
42
break: )            ; show evaluation stack
0(break MyFun)
1(cond ((gt X 10) (break MyFun) (list X 'done)) (t 'exit))
2(M 32)
break: 2            ; go to level 2 in the stack 
(M 32)
brk2#: X            ; show value of X  [note prompt shows level]
0
brk2#: 1            ; go to level 1 in the stack
(cond ((gt X 10) (break MyFun) (list X 'done)) (t 'exit))
brk1#: X            ; show value of X again
42
brk1#: 0            ; go to level 0
(break MyFun)
brk0#: []           ; go to the top
(break MyFun)
break: ]            ; show binding environment at this level [note prompt]
Env@ 0x46c05790 nargs = 1 s=a 
  X              = 42 <=> 0
Env@ 0x46c057c0 nargs = 0 s=a 
Env@ 0x46c05d60 nargs = 0 s=a 
break: nil          ; exit break mode
(42 done)
alps: 


Debugging macros with (macroexpand)

This user-defined macro is part of the primitives provided in the
prims.al file. It can be used to examine the effect of a macro
expansions without actually evaluating the expansion.

Here is what the result of applying (macroexpand) on the invocation of
the FOR macro (also defined in prims.al).

(macroexpand FOR I 1 10 (print I)) ;=>
(let ((I 1)) (while (le I 10) (print I) (incr I)))

The definition of (macroexpand) without the error checking is:

(defmacro macroexpand (Macro Args) `((fexpr ,@(cdr (eval Macro))) ,@Args))

Essentially (macroexpand) transforms the macro-form bound to the formal
parameter Macro into a fexpr-form by replacing the symbol <macro> in the
first element of the form associated with Macro by <fexpr> and applying
the resulting form to the arguments Args.

(pp (macroexpand macroexpand FOR I 1 10 (print I))) => t

((fexpr (X) 
    (list 'let (list (list (car X) (cadr X))) 
     (list* 'while (list 'le (car X) (caddr X)) 
      (append (cdddr X) (list (list 'incr (car X))))))) I 1 10 (print I))

Note: This simplified expansion was generated using the Guy Steele qq package in
qq.al

(eval (macroexpand macroexpand FOR I 1 10 (print I))) =>
      (let ((I 1)) (while (le I 10) (print I) (incr I)))


Parking Lot
-----------
Different ways of computing the sum of the first N positive integers
alps: (defun S (N) (! 2 (+ N 1))) ; binomial funcion
S
alps: (S 100)
5050
alps: (defun S1 (N) (/ (* N (+ N 1)) 2)) ; formula
S1
alps: (defun S2 (N) (r '+ (i N))) ; APL reduce
S2
alps: (defun S3 (N) (apply '+ (explod (i N)))) ; lisp apply +
S3
alps: (mapcar '(lambda (F) (F 1000)) '(S S1 S2 S3))
(500500 500500 500500 500500)

;What does this do ? 
(k (> (- (i A B) #IO) (- (p A) 1)) B) 
;=> ""  for A & B both nil 
(a B "Hello Polly")
(a A "o Pl")
(k (> (- (i A B) #IO) (- (p A) 1)) B) ;=> "Hey"


Appendix
--------

APL Idioms
----------
For a more complete list of idioms see the file "lisp/idioms.al"

; Replacing a given character within a string by blanks

(defun blankc (S C) (let ((R (~ (e C S)))) (ex R (k R S))))

; (blankc "10/10/33" "/") => "10 10 33"

; Removing a given character in a string

(defun Strip (S C) (k (<> C S) S))

; (Strip "10 10 33" " ") ;=> "101033"

; Remove leading zeros

(defun RZero (X) (k (s 'v (<> "0" X)) X))

; (RZero "00001240") ;=> "1240"

; Remove leading blanks

(defun RB (X) (k (s 'v (<> " " X)) X))

; (RB "  Hello Polly") => "Hello Polly"

; Trim trailing blanks
(defun Trim (L) (dp (- #IO (i (<> " " (rev L)) 1)) L)) 

; (Trim "Short line      ") => "Short line"

Arithmetic accuracy
-------------------

All numeric values are stored in IEEE 754 double precision floating
point format. For complex numbers the real and imaginary part are each
stored as double precision values.  For most engineering applications
the accuracy afforded by the double precision floating point format is
quite adequate. It provides for approximately 15 decimal digits of
accuracy, the mantissa of the floating point value being 56 bits.

(l 10 (exp 2 56)) => 16.85767976

However, when subtracting numbers that differ only after 15 digits the
results are only going to be accurate to 1 digit or less.

The function G taken from [Boas] illustrates this problem:
 (require 'trig)
 (de G(x) (- (l (sqrt(/ (+ 1 x) (- 1 x)))) (tan x)))
 (G .0015)     ;=> 6.060690144e-16
 However expressing the parts of the function as series
 (l (sqrt(/ (+ 1 x) (- 1 x)))) = (+  x (/ (exp x 3) 3) (/ (exp x 5) 5) ...)
 and (tan x) =  (+  x (/ (exp x 3) 3) (/ (* 2 (exp x 5)) 15)
                   (/ (* 17 (exp x 7)) 315) ...)
 Expressing G as the difference of the two series:
 (G x) = (+ (/ (exp x 5) 15) (/ (* 4 (exp x 7)) 45) ...)
 So defining G1 with just 2 terms of the resulting series:
 (de G1 (x) (+ (/ (exp x 5) 15) (/ (* 4 (exp x 7)) 45)))
 (G1 .0015)   ;=> 5.062515188e-16
 This would have an error of less than (exp .0015 7) =>
 1.70859375e-20

If accuracy is important with a complicated non polynomial function,
coding it up in different forms and comparing the results can help to
improve the level of confidence. Plotting parts of the function over
the domain of interest can also provide some insights. As in the
example above both parts of the function have a zero at x=0 so for
small values of x they will get arbitrarily close. In this case it is
necessary to find a suitable approximation to the function for small
x such as G1.

Sums of series can also lead to discrepancies depending on how they
are expressed. Adding a very small number to a very large one can lead
to inaccuracies.

      (a #SD 17) ;; Set the number of siginficant digits to display to 17
      (+ 1234567890 .000123)    ;=> 1234567890.000123
      (+ 1234567890 .0000123)   ;=> 1234567890.0000124
      (+ 1234567890 .00000123)  ;=> 1234567890.0000012
      (+ 1234567890 .000000123) ;=> 1234567890.0000002

Note that the 17th digit is not reliable. This is because of the
limitation of the mantissa to 56 bits as mentioned above.

Working with escape codes
-------------------------


The backslash character \ can also be used to enter control characters
i.e. characters whose ASCII code has a value less than the value of the
space character (decimal 32, hexadecimal 0x20).

A special case is needed is to represent the <ctrl-\> character ASCII
value 28. The sequence \q is used to represent this value in symbolic
expressions.

"ab\qcde" => ab<ctrl-\>cde
(chr 28) ;=> "\q"

See Appendix XX for the escape codes for all ASCII control characters.

The sequence of characters used to place the cursor at the top of the
screen of a Digital Equipment Corporation vt100 terminal and clear it
is "<escape>[H<escape>[2J". This can be represented as a string
literal by "\[[H\[[2J" where "\[" produces the escape character ASCII
code 27.  This could be used programmaticially as follows:

(a CLR "\[[H\[[2J") ; assign the cursor up and clear sequence to CLR
CLR ;=> "\[[H\[[2J"


; convert the ascii values of each character to numeric
(num CLR) ;=> [27  91  72  27  91  50  74]
; print the numbers in hexadecimal
(fmt (num CLR):::16) ;=> "1B 5B 48 1B 5B 32 4A"

In order to output the raw ascii characters to control the cursor use
the function (princ <chr>)

(princ CLR) => sends cursor to top left corner and clears the screen.

Note that if this expression is entered at the alps prompt, the
default prompt-read-eval-print loop will print the symbolic value
"\[[H\[[2J" at the top of the screen followed by the alps prompt since
(princ) returns its argument.


Escape codes for alps reader.
----------------------------


\@ => <ctrl-@> => ASCII code 0
\A => <ctrl-A> => ASCII code 1
\B => <ctrl-B> => ASCII code 2
\C => <ctrl-C> => ASCII code 3
\D => <ctrl-D> => ASCII code 4
\E => <ctrl-E> => ASCII code 5
\F => <ctrl-F> => ASCII code 6
\G => <ctrl-G> => ASCII code 7
\H => <ctrl-H> => ASCII code 8
\I => <ctrl-I> => ASCII code 9
\J => <ctrl-J> => ASCII code 10 also \n <newline>
\K => <ctrl-K> => ASCII code 11
\L => <ctrl-L> => ASCII code 12
\M => <ctrl-M> => ASCII code 13
\N => <ctrl-N> => ASCII code 14
\O => <ctrl-O> => ASCII code 15
\P => <ctrl-P> => ASCII code 16
\Q => <ctrl-Q> => ASCII code 17
\R => <ctrl-R> => ASCII code 18
\S => <ctrl-S> => ASCII code 19
\T => <ctrl-T> => ASCII code 20
\U => <ctrl-U> => ASCII code 21
\V => <ctrl-V> => ASCII code 22
\W => <ctrl-W> => ASCII code 23
\X => <ctrl-X> => ASCII code 24
\Y => <ctrl-Y> => ASCII code 25
\Z => <ctrl-Z> => ASCII code 26
\[ => <ctrl-[> => ASCII code 27 
\q => <ctrl-\> => ASCII code 28 note \q instead of \\ since \\ quotes \
\] => <ctrl-]> => ASCII code 29
\^ => <ctrl-^> => ASCII code 30
\_ => <ctrl-_> => ASCII code 31
   
(a #IO 0)
(chr (i 32)) =>
"\@\A\B\C\D\E\F\G\H\I\n\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z\[\q\]\^\_"
